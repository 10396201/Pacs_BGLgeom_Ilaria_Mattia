\hypertarget{maximum__flow__imp_8hpp_source}{
\section{maximum\_\-flow\_\-imp.hpp}
}


\begin{footnotesize}\begin{alltt}
00001 \textcolor{preprocessor}{#ifndef HH\_MAXIMUM\_FLOW\_IMP\_HH}
00002 \textcolor{preprocessor}{}\textcolor{preprocessor}{#define HH\_MAXIMUM\_FLOW\_IMP\_HH}
00003 \textcolor{preprocessor}{}
00004 \textcolor{preprocessor}{#include <map>}
00005 \textcolor{preprocessor}{#include <tuple>}
00006 \textcolor{preprocessor}{#include <boost/graph/adjacency\_list.hpp>}
00007 \textcolor{preprocessor}{#include <boost/graph/push\_relabel\_max\_flow.hpp>}                \textcolor{comment}{//per push\_relabe
      l}
00008 \textcolor{preprocessor}{#include <boost/property\_map/property\_map.hpp>}
00009 \textcolor{preprocessor}{#include <boost/graph/properties.hpp>}                                   \textcolor{comment}{//per la 
      definizione di vertex\_index richiesta da push\_relabel}
00010 
00011 \textcolor{preprocessor}{#include "\hyperlink{generic__point_8hpp}{generic_point.hpp}"}
00012 \textcolor{preprocessor}{#include "edge\_property\_max\_flow.hpp"}
00013 
00014 
00015 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Graph>
00016 \textcolor{keywordtype}{double} maximum\_flow     (Graph \textcolor{keyword}{const} &G, 
00017                                         \textcolor{keyword}{typename} boost::graph\_traits<Graph>::vert
      ex\_descriptor s,
00018                                         \textcolor{keyword}{typename} boost::graph\_traits<Graph>::vert
      ex\_descriptor t)\{
00019         
00020         \textcolor{comment}{//Desumiamo i vari selettori dal grafo G preesistente:}
00021         \textcolor{keyword}{typedef} boost::adjacency\_list   <\textcolor{keyword}{typename} Graph::out\_edge\_list\_selector,
00022                                                                         \textcolor{keyword}{typename} 
      Graph::vertex\_list\_selector,
00023                                                                         \textcolor{keyword}{typename} 
      Graph::directed\_selector,
00024                                                                         boost::no
      \_vertex\_bundle,         \textcolor{comment}{//vertex\_bundle\_type<Graph>::type, non ci servono le coor
      dinate per ora!}
00025                                                                         
      \hyperlink{structedge__prop__max__flow__t}{edge_prop_max_flow_t}>   Flow\_Graph;
00026         
00027         \textcolor{comment}{//copiamo il grafo in Flow\_Graph:}
00028         Flow\_Graph FG(num\_vertices(G));                         \textcolor{comment}{//crea grafo con 
      stesso numero di vertici di G}
00029         \textcolor{keyword}{typedef} \textcolor{keyword}{typename} boost::graph\_traits<Flow\_Graph>::edge\_descriptor Edge\_fg
      ;
00030         std::map<Edge\_fg, Edge\_fg> rev\_map;
00031         
00032         build\_flow\_graph<Graph, Flow\_Graph, Edge\_fg> (G, FG, rev\_map);
00033         
00034         \textcolor{comment}{//Ora chiamiamo l'algoritmo:}
00035         \textcolor{keywordtype}{double} out\_max\_flow;
00036         out\_max\_flow = boost::push\_relabel\_max\_flow(
00037                                         FG,
00038                                         s,
00039                                         t,
00040                                         boost::get(&edge\_prop\_max\_flow\_t::capacit
      y, FG), 
00041                                         boost::get(&edge\_prop\_max\_flow\_t::residua
      l\_capacity, FG),
00042                                         boost::make\_assoc\_property\_map(rev\_map),
00043                                         boost::get(boost::vertex\_index, FG)
00044                                         );              \textcolor{comment}{//manca l'ultimo parametr
      o con la map dei vertex\_index, che è default}
00045         
00046         \textcolor{keywordflow}{return} out\_max\_flow;
00047                                 
00048 \} \textcolor{comment}{//max\_flow;}
00049 
00050 
00051 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Graph, \textcolor{keyword}{typename} Flow\_Graph, \textcolor{keyword}{typename} Edge\_fg>
00052 \textcolor{keywordtype}{void} build\_flow\_graph(Graph \textcolor{keyword}{const}& G, Flow\_Graph & FG, std::map<Edge\_fg, Edge\_fg>
      & rev\_map)\{
00053 
00054         \textcolor{keyword}{typedef} \textcolor{keyword}{typename} boost::graph\_traits<Graph>::edge\_iterator Edge\_g;
00055         \textcolor{keyword}{typedef} \textcolor{keyword}{typename} boost::graph\_traits<Graph>::vertex\_descriptor Vertex\_g;
00056                 
00057         Edge\_g e\_it, e\_end;
00058         Edge\_fg e, rev\_e;
00059         \textcolor{keywordtype}{bool} inserted;
00060         Vertex\_g u,v;
00061         \textcolor{keywordflow}{for}( std::tie(e\_it, e\_end) = boost::edges(G); e\_it != e\_end; ++e\_it)\{
00062                 u = boost::source(*e\_it, G);
00063                 v = boost::target(*e\_it, G);
00064                 std::tie(e, inserted) = boost::add\_edge(u, v, FG);
00065                 \textcolor{comment}{//inizializziamo insieme capacity e residual\_capacity allo stesso
       valore. Residual\_cap = cap vuol dire che non c'è flusso lì.}
00066                 FG[e].capacity = FG[e].residual\_capacity = G[*e\_it].capacity;           \textcolor{comment}{/
      /questa capacità è il diam che leggiamo dal file di input Zunino.}
00067                 std::tie(rev\_e, inserted) = boost::add\_edge(v, u, FG);
00068                 FG[rev\_e].capacity = FG[rev\_e].residual\_capacity = 0.0;         \textcolor{comment}{/
      /per specifiche dell'algoritmo, vanno messe a zero}
00069                 rev\_map[e] = rev\_e;
00070                 rev\_map[rev\_e] = e;     
00071         \}
00072 
00073 \}       \textcolor{comment}{//build\_flow\_graph}
00074 
00075 
00076 \textcolor{preprocessor}{#endif //HH\_MAXIMUM\_FLOW\_IMP\_HH}
\end{alltt}\end{footnotesize}
