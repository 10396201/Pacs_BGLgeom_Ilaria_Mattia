<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BGL Interface: include/intersector_base_class.hpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<h1>include/intersector_base_class.hpp</h1><a href="intersector__base__class_8hpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*======================================================================</span>
<a name="l00002"></a>00002 <span class="comment">                        &quot;[nome_progetto]&quot;</span>
<a name="l00003"></a>00003 <span class="comment">        Course on Advanced Programming for Scientific Computing</span>
<a name="l00004"></a>00004 <span class="comment">                      Politecnico di Milano</span>
<a name="l00005"></a>00005 <span class="comment">                          A.Y. 2015-2016</span>
<a name="l00006"></a>00006 <span class="comment">                  </span>
<a name="l00007"></a>00007 <span class="comment">         Copyright (C) 2016 Ilaria Speranza &amp; Mattia Tantardini</span>
<a name="l00008"></a>00008 <span class="comment">======================================================================*/</span>
<a name="l00017"></a>00017 
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 <span class="preprocessor">#ifndef HH_INTERSECTOR_BASE_CLASS_HH</span>
<a name="l00020"></a>00020 <span class="preprocessor"></span><span class="preprocessor">#define HH_INTERSECTOR_BASE_CLASS_HH</span>
<a name="l00021"></a>00021 <span class="preprocessor"></span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;array&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;tuple&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;cmath&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;limits&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;boost/graph/graph_traits.hpp&gt;</span>
<a name="l00028"></a>00028 
<a name="l00029"></a>00029 <span class="preprocessor">#include &quot;<a class="code" href="generic__point_8hpp.html" title="Templete class to handle points in 2D or 3D (or even greater).">generic_point.hpp</a>&quot;</span>
<a name="l00030"></a>00030 <span class="comment">//#include &quot;point2D.hpp&quot;</span>
<a name="l00031"></a>00031 
<a name="l00032"></a><a class="code" href="intersector__base__class_8hpp.html#ae194046620d0aa0c920eb490d2b43920">00032</a> <span class="keyword">typedef</span> std::array&lt;double,2&gt; <a class="code" href="intersector__base__class_8hpp.html#ae194046620d0aa0c920eb490d2b43920" title="Ecco il trucco forse!!! Una volta stabilita tutta la geometria, questa classe dovrebbe...">Vector</a>;
<a name="l00033"></a>00033 
<a name="l00035"></a>00035 <span class="keyword">namespace</span>{
<a name="l00037"></a>00037         <span class="keyword">inline</span> <span class="keywordtype">double</span> dot(<a class="code" href="intersector__base__class_8hpp.html#ae194046620d0aa0c920eb490d2b43920" title="Ecco il trucco forse!!! Una volta stabilita tutta la geometria, questa classe dovrebbe...">Vector</a> <span class="keyword">const</span>&amp; a, <a class="code" href="intersector__base__class_8hpp.html#ae194046620d0aa0c920eb490d2b43920" title="Ecco il trucco forse!!! Una volta stabilita tutta la geometria, questa classe dovrebbe...">Vector</a> <span class="keyword">const</span>&amp; b){
<a name="l00038"></a>00038                 <span class="keywordflow">return</span> a[0]*b[0] + a[1]*b[1];
<a name="l00039"></a>00039         }
<a name="l00040"></a>00040         
<a name="l00042"></a>00042         <span class="keyword">inline</span> <span class="keywordtype">double</span> norm(<a class="code" href="intersector__base__class_8hpp.html#ae194046620d0aa0c920eb490d2b43920" title="Ecco il trucco forse!!! Una volta stabilita tutta la geometria, questa classe dovrebbe...">Vector</a> <span class="keyword">const</span>&amp; a){
<a name="l00043"></a>00043                 <span class="keywordflow">return</span> std::sqrt(dot(a,a));
<a name="l00044"></a>00044         }
<a name="l00045"></a>00045         
<a name="l00047"></a>00047         <span class="keyword">inline</span> <a class="code" href="intersector__base__class_8hpp.html#ae194046620d0aa0c920eb490d2b43920" title="Ecco il trucco forse!!! Una volta stabilita tutta la geometria, questa classe dovrebbe...">Vector</a> operator+ (<a class="code" href="intersector__base__class_8hpp.html#ae194046620d0aa0c920eb490d2b43920" title="Ecco il trucco forse!!! Una volta stabilita tutta la geometria, questa classe dovrebbe...">Vector</a> <span class="keyword">const</span>&amp; a, <a class="code" href="intersector__base__class_8hpp.html#ae194046620d0aa0c920eb490d2b43920" title="Ecco il trucco forse!!! Una volta stabilita tutta la geometria, questa classe dovrebbe...">Vector</a> <span class="keyword">const</span>&amp; b){
<a name="l00048"></a>00048                 <span class="keywordflow">return</span> <a class="code" href="intersector__base__class_8hpp.html#ae194046620d0aa0c920eb490d2b43920" title="Ecco il trucco forse!!! Una volta stabilita tutta la geometria, questa classe dovrebbe...">Vector</a>{a[0]+b[0], a[1]+b[1]};
<a name="l00049"></a>00049         }
<a name="l00050"></a>00050         
<a name="l00052"></a>00052         <span class="keyword">inline</span> <a class="code" href="intersector__base__class_8hpp.html#ae194046620d0aa0c920eb490d2b43920" title="Ecco il trucco forse!!! Una volta stabilita tutta la geometria, questa classe dovrebbe...">Vector</a> operator- (<a class="code" href="intersector__base__class_8hpp.html#ae194046620d0aa0c920eb490d2b43920" title="Ecco il trucco forse!!! Una volta stabilita tutta la geometria, questa classe dovrebbe...">Vector</a> <span class="keyword">const</span>&amp; a, <a class="code" href="intersector__base__class_8hpp.html#ae194046620d0aa0c920eb490d2b43920" title="Ecco il trucco forse!!! Una volta stabilita tutta la geometria, questa classe dovrebbe...">Vector</a> <span class="keyword">const</span>&amp; b){
<a name="l00053"></a>00053                 <span class="keywordflow">return</span> <a class="code" href="intersector__base__class_8hpp.html#ae194046620d0aa0c920eb490d2b43920" title="Ecco il trucco forse!!! Una volta stabilita tutta la geometria, questa classe dovrebbe...">Vector</a>{a[0]-b[0], a[1]-b[1]};
<a name="l00054"></a>00054         }       
<a name="l00055"></a>00055         
<a name="l00056"></a>00056         <span class="comment">//Both the overloading needed!</span>
<a name="l00058"></a>00058 <span class="comment"></span>        <span class="keyword">inline</span> <a class="code" href="intersector__base__class_8hpp.html#ae194046620d0aa0c920eb490d2b43920" title="Ecco il trucco forse!!! Una volta stabilita tutta la geometria, questa classe dovrebbe...">Vector</a> operator* (<span class="keywordtype">double</span> <span class="keyword">const</span>&amp; k, <a class="code" href="intersector__base__class_8hpp.html#ae194046620d0aa0c920eb490d2b43920" title="Ecco il trucco forse!!! Una volta stabilita tutta la geometria, questa classe dovrebbe...">Vector</a> <span class="keyword">const</span>&amp; a){
<a name="l00059"></a>00059                 <span class="keywordflow">return</span> <a class="code" href="intersector__base__class_8hpp.html#ae194046620d0aa0c920eb490d2b43920" title="Ecco il trucco forse!!! Una volta stabilita tutta la geometria, questa classe dovrebbe...">Vector</a>{k*a[0], k*a[1]};
<a name="l00060"></a>00060         }
<a name="l00061"></a>00061         
<a name="l00063"></a>00063 
<a name="l00067"></a>00067         std::pair&lt;bool, Vector&gt;
<a name="l00068"></a>00068         solve (std::array&lt;Vector,2&gt; <span class="keyword">const</span>&amp; A,
<a name="l00069"></a>00069                 <a class="code" href="intersector__base__class_8hpp.html#ae194046620d0aa0c920eb490d2b43920" title="Ecco il trucco forse!!! Una volta stabilita tutta la geometria, questa classe dovrebbe...">Vector</a> b,
<a name="l00070"></a>00070                 <span class="keywordtype">double</span> <span class="keyword">const</span>&amp; tol)
<a name="l00071"></a>00071         {
<a name="l00072"></a>00072         <span class="keyword">auto</span> D = A[0][0]*A[1][1] - A[1][0]*A[0][1];
<a name="l00073"></a>00073         <span class="keywordflow">if</span> (std::abs(D) &lt;= tol)
<a name="l00074"></a>00074             <span class="keywordflow">return</span> std::make_pair(<span class="keyword">false</span>, <a class="code" href="intersector__base__class_8hpp.html#ae194046620d0aa0c920eb490d2b43920" title="Ecco il trucco forse!!! Una volta stabilita tutta la geometria, questa classe dovrebbe...">Vector</a>{0,0});
<a name="l00075"></a>00075         D=1./D;
<a name="l00076"></a>00076         <a class="code" href="intersector__base__class_8hpp.html#ae194046620d0aa0c920eb490d2b43920" title="Ecco il trucco forse!!! Una volta stabilita tutta la geometria, questa classe dovrebbe...">Vector</a> res;
<a name="l00077"></a>00077         res[0] = D * (A[1][1]*b[0] - A[0][1]*b[1]);
<a name="l00078"></a>00078         res[1] = D * (A[0][0]*b[1] - A[1][0]*b[0]);
<a name="l00079"></a>00079         <span class="keywordflow">return</span> std::make_pair(<span class="keyword">true</span>, res);
<a name="l00080"></a>00080         }       <span class="comment">//solve</span>
<a name="l00081"></a>00081 }       <span class="comment">//namespace</span>
<a name="l00082"></a>00082 
<a name="l00083"></a>00083 
<a name="l00084"></a>00084 <span class="keyword">namespace </span>Geometry{
<a name="l00092"></a><a class="code" href="classGeometry_1_1Linear__edge.html">00092</a>         <span class="keyword">class </span><a class="code" href="classGeometry_1_1Linear__edge.html" title="A simple class that hanlde a linear edge  This class is thought to manage the description...">Linear_edge</a>{
<a name="l00093"></a>00093                 <span class="keyword">public</span>:
<a name="l00095"></a><a class="code" href="classGeometry_1_1Linear__edge.html#a7bc8e67881017b2f3a60b513f81aa45f">00095</a>                         <a class="code" href="classGeometry_1_1Linear__edge.html#a7bc8e67881017b2f3a60b513f81aa45f" title="Default constructor.">Linear_edge</a>() : extremes{point&lt;2&gt;(), point&lt;2&gt;()}, extremes_are_set(<span class="keyword">false</span>) {};
<a name="l00096"></a>00096                 
<a name="l00098"></a><a class="code" href="classGeometry_1_1Linear__edge.html#ac3cb6d63d81f758cae11b315c81acc6e">00098</a>                         <a class="code" href="classGeometry_1_1Linear__edge.html#ac3cb6d63d81f758cae11b315c81acc6e" title="Constructor.">Linear_edge</a>(point&lt;2&gt; <span class="keyword">const</span>&amp; SRC, point&lt;2&gt; <span class="keyword">const</span>&amp; TGT) : extremes{SRC, TGT}, extremes_are_set(<span class="keyword">true</span>) {};
<a name="l00099"></a>00099                         
<a name="l00101"></a>00101                         <a class="code" href="classGeometry_1_1Linear__edge.html#a7bc8e67881017b2f3a60b513f81aa45f" title="Default constructor.">Linear_edge</a>(<a class="code" href="classGeometry_1_1Linear__edge.html#a7bc8e67881017b2f3a60b513f81aa45f" title="Default constructor.">Linear_edge</a> <span class="keyword">const</span>&amp;) = <span class="keywordflow">default</span>;
<a name="l00102"></a>00102                         
<a name="l00104"></a>00104                         <a class="code" href="classGeometry_1_1Linear__edge.html#a7bc8e67881017b2f3a60b513f81aa45f" title="Default constructor.">Linear_edge</a> &amp; <a class="code" href="classGeometry_1_1Linear__edge.html#ab1cab14e36cf0e1d51bc68dea4c736a3" title="Assignment operator.">operator=</a>(<a class="code" href="classGeometry_1_1Linear__edge.html#a7bc8e67881017b2f3a60b513f81aa45f" title="Default constructor.">Linear_edge</a> <span class="keyword">const</span>&amp;) = <span class="keywordflow">default</span>;
<a name="l00105"></a>00105                         
<a name="l00107"></a><a class="code" href="classGeometry_1_1Linear__edge.html#a567dadf0feb7d130903b7d2aaebfdf08">00107</a>                         <span class="keywordtype">void</span> <span class="keyword">set</span>(point&lt;2&gt; <span class="keyword">const</span>&amp; SRC, point&lt;2&gt; <span class="keyword">const</span>&amp; TGT){
<a name="l00108"></a>00108                                 extremes[0] = SRC;
<a name="l00109"></a>00109                                 extremes[1] = TGT;
<a name="l00110"></a>00110                                 extremes_are_set = <span class="keyword">true</span>;
<a name="l00111"></a>00111                         }
<a name="l00112"></a>00112                         
<a name="l00117"></a><a class="code" href="classGeometry_1_1Linear__edge.html#a93a04309b0e46c40eb803a60d213a527">00117</a>                         point&lt;2&gt; <a class="code" href="classGeometry_1_1Linear__edge.html#a93a04309b0e46c40eb803a60d213a527" title="Overloading of operator[] to access each of the two end points. Usefull in algorithms...">operator[]</a>(std::size_t i){ <span class="keywordflow">return</span> extremes[i]; }
<a name="l00118"></a>00118                         point&lt;2&gt; <a class="code" href="classGeometry_1_1Linear__edge.html#a93a04309b0e46c40eb803a60d213a527" title="Overloading of operator[] to access each of the two end points. Usefull in algorithms...">operator[]</a>(std::size_t i)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> extremes[i]; }
<a name="l00119"></a>00119                                         
<a name="l00120"></a>00120                 <span class="keyword">private</span>:
<a name="l00122"></a>00122                         std::array&lt;point&lt;2&gt;,2&gt; extremes;
<a name="l00124"></a>00124                         <span class="keywordtype">bool</span> extremes_are_set;
<a name="l00125"></a>00125         };      <span class="comment">//Linear_edge</span>
<a name="l00126"></a>00126         
<a name="l00127"></a>00127         
<a name="l00129"></a>00129 
<a name="l00138"></a><a class="code" href="structGeometry_1_1Intersection.html">00138</a>         <span class="keyword">struct</span>
<a name="l00139"></a>00139         <a class="code" href="structGeometry_1_1Intersection.html" title="A simple struct that contains the result of the intersection test.">Intersection</a>
<a name="l00140"></a>00140         {
<a name="l00142"></a>00142 
<a name="l00145"></a><a class="code" href="structGeometry_1_1Intersection.html#a45563c77f618ad3a58931ed051032d45">00145</a>         <span class="keywordtype">bool</span> intersect = <span class="keyword">false</span>;
<a name="l00147"></a><a class="code" href="structGeometry_1_1Intersection.html#a30339c7930808caca3df89da3df2b034">00147</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numberOfIntersections = 0u;
<a name="l00149"></a><a class="code" href="structGeometry_1_1Intersection.html#abd19dce0869cb0e34ce94f48138b8f38">00149</a>         std::array&lt;point&lt;2&gt;,2&gt; intersectionPoint = std::array&lt;point&lt;2&gt;,2&gt;{point&lt;2&gt;(), point&lt;2&gt;()};
<a name="l00155"></a><a class="code" href="structGeometry_1_1Intersection.html#ac26994bdf89460be8b13c1304796b6bb">00155</a>         std::array&lt;std::array&lt;bool,2&gt;, 2&gt; endPointIsIntersection =
<a name="l00156"></a>00156             std::array&lt;std::array&lt;bool,2&gt;, 2&gt;{std::array&lt;bool,2&gt;{<span class="keyword">false</span>,<span class="keyword">false</span>}, std::array&lt;bool,2&gt;{<span class="keyword">false</span>,<span class="keyword">false</span>} };
<a name="l00165"></a><a class="code" href="structGeometry_1_1Intersection.html#a15cd54d14fc1ddc1f4499dc49e1d5508">00165</a>         std::array&lt;std::array&lt;int,2&gt;, 2&gt; otherEdgePoint =
<a name="l00166"></a>00166             std::array&lt;std::array&lt;int,2&gt;, 2&gt;{std::array&lt;int,2&gt;{-1,-1}, std::array&lt;int,2&gt;{-1,-1}};
<a name="l00168"></a><a class="code" href="structGeometry_1_1Intersection.html#aad30a67c865aca570fff7f29a9251903">00168</a>         <span class="keywordtype">bool</span> parallel = <span class="keyword">false</span>;
<a name="l00170"></a><a class="code" href="structGeometry_1_1Intersection.html#a3a5657af0debf92f5653e1f7627ce417">00170</a>         <span class="keywordtype">bool</span> identical = <span class="keyword">false</span>;
<a name="l00172"></a><a class="code" href="structGeometry_1_1Intersection.html#a468bd7fe9703f6bd57aabbd0d957668e">00172</a>         <span class="keywordtype">bool</span> collinear = <span class="keyword">false</span>;
<a name="l00174"></a><a class="code" href="structGeometry_1_1Intersection.html#adde469457ed9ef6a0a9df12d5c5be23f">00174</a>         <span class="keywordtype">bool</span> good = <span class="keyword">true</span>;
<a name="l00176"></a><a class="code" href="structGeometry_1_1Intersection.html#a08f4c2d8a818d21883e35c932088b6ed">00176</a>         <span class="keywordtype">double</span> distance = 0.0;
<a name="l00177"></a>00177         };      <span class="comment">//Intersection</span>
<a name="l00178"></a>00178         
<a name="l00179"></a>00179         
<a name="l00189"></a>00189         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Edge_rapresentation_t = Linear_edge&gt;
<a name="l00190"></a>00190         <a class="code" href="structGeometry_1_1Intersection.html" title="A simple struct that contains the result of the intersection test.">Intersection</a> compute_intersection       (<a class="code" href="classGeometry_1_1Linear__edge.html" title="A simple class that hanlde a linear edge  This class is thought to manage the description...">Linear_edge</a> <span class="keyword">const</span>&amp; Edge1,
<a name="l00191"></a>00191                                                                                 <a class="code" href="classGeometry_1_1Linear__edge.html" title="A simple class that hanlde a linear edge  This class is thought to manage the description...">Linear_edge</a> <span class="keyword">const</span>&amp; Edge2,
<a name="l00192"></a>00192                                                                                 <span class="keywordtype">double</span> <span class="keyword">const</span> tol = 20*std::numeric_limits&lt;double&gt;::epsilon()){
<a name="l00193"></a>00193                                                                 
<a name="l00194"></a>00194         <a class="code" href="structGeometry_1_1Intersection.html" title="A simple struct that contains the result of the intersection test.">Intersection</a> out;
<a name="l00195"></a>00195     <span class="comment">//[0][0] -&gt;1</span>
<a name="l00196"></a>00196     <span class="comment">//[0][1] -&gt;2</span>
<a name="l00197"></a>00197     <span class="comment">//[1][0] -&gt;3</span>
<a name="l00198"></a>00198     <span class="comment">//[1][1] -&gt;4</span>
<a name="l00199"></a>00199     <span class="keyword">auto</span> v1= Edge1[1]-Edge1[0];
<a name="l00200"></a>00200     <span class="keyword">auto</span> v2= Edge2[1]-Edge2[0];
<a name="l00201"></a>00201     <span class="keyword">auto</span> len1 = norm(v1);
<a name="l00202"></a>00202     <span class="keyword">auto</span> len2 = norm(v2);
<a name="l00203"></a>00203     <span class="comment">// Tolerance for distances</span>
<a name="l00204"></a>00204     <span class="keywordtype">double</span> tol_dist=tol*std::max(len1,len2);
<a name="l00205"></a>00205     <span class="comment">// I need to scale the tolerance to check</span>
<a name="l00206"></a>00206     <span class="comment">// parallelism correctly</span>
<a name="l00207"></a>00207     <span class="keyword">auto</span> tol_sys=2.0*tol*len1*len1*len2*len2;
<a name="l00208"></a>00208     <span class="comment">// First check if segments meets at the end</span>
<a name="l00209"></a>00209     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;i&lt;2;++i)
<a name="l00210"></a>00210       {
<a name="l00211"></a>00211         point&lt;2&gt; <span class="keyword">const</span> &amp; P1=Edge1[i];
<a name="l00212"></a>00212         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0;j&lt;2;++j)
<a name="l00213"></a>00213           {
<a name="l00214"></a>00214             point&lt;2&gt; <span class="keyword">const</span> &amp; P2=Edge2[j];
<a name="l00215"></a>00215             <span class="keyword">auto</span> dist=norm(P1-P2);
<a name="l00216"></a>00216             <span class="keywordflow">if</span> (dist&lt;=tol_dist)
<a name="l00217"></a>00217               {
<a name="l00218"></a>00218                 <span class="keywordflow">if</span>(out.<a class="code" href="structGeometry_1_1Intersection.html#a30339c7930808caca3df89da3df2b034" title="Number of intersections (max 2).">numberOfIntersections</a>&gt;=2)
<a name="l00219"></a>00219                   {
<a name="l00220"></a>00220                     std::cerr&lt;&lt;
<a name="l00221"></a>00221                       <span class="stringliteral">&quot;Something wrong, cannot have more that 2 intersections&quot;</span>
<a name="l00222"></a>00222                              &lt;&lt;std::endl;
<a name="l00223"></a>00223                     out.<a class="code" href="structGeometry_1_1Intersection.html#adde469457ed9ef6a0a9df12d5c5be23f" title="Something is not ok.">good</a>=<span class="keyword">false</span>;
<a name="l00224"></a>00224                     <span class="keywordflow">return</span> out;
<a name="l00225"></a>00225                   }
<a name="l00226"></a>00226                 out.<a class="code" href="structGeometry_1_1Intersection.html#a45563c77f618ad3a58931ed051032d45" title="Segments intersects.">intersect</a>=<span class="keyword">true</span>;
<a name="l00227"></a>00227                 out.<a class="code" href="structGeometry_1_1Intersection.html#abd19dce0869cb0e34ce94f48138b8f38" title="Intersection points coordinates.">intersectionPoint</a>[out.<a class="code" href="structGeometry_1_1Intersection.html#a30339c7930808caca3df89da3df2b034" title="Number of intersections (max 2).">numberOfIntersections</a>++]=P1;
<a name="l00228"></a>00228                 out.<a class="code" href="structGeometry_1_1Intersection.html#ac26994bdf89460be8b13c1304796b6bb">endPointIsIntersection</a>[0][i]=<span class="keyword">true</span>;
<a name="l00229"></a>00229                 out.<a class="code" href="structGeometry_1_1Intersection.html#ac26994bdf89460be8b13c1304796b6bb">endPointIsIntersection</a>[1][j]=<span class="keyword">true</span>;
<a name="l00230"></a>00230                 out.<a class="code" href="structGeometry_1_1Intersection.html#a15cd54d14fc1ddc1f4499dc49e1d5508">otherEdgePoint</a>[0][i]=j;
<a name="l00231"></a>00231                 out.<a class="code" href="structGeometry_1_1Intersection.html#a15cd54d14fc1ddc1f4499dc49e1d5508">otherEdgePoint</a>[1][j]=i;
<a name="l00232"></a>00232               }
<a name="l00233"></a>00233           }
<a name="l00234"></a>00234       }
<a name="l00235"></a>00235     <span class="comment">// Handle the case where the two edges are identical!</span>
<a name="l00236"></a>00236     <span class="keywordflow">if</span> (out.<a class="code" href="structGeometry_1_1Intersection.html#a30339c7930808caca3df89da3df2b034" title="Number of intersections (max 2).">numberOfIntersections</a>==2u)
<a name="l00237"></a>00237       {
<a name="l00238"></a>00238         out.<a class="code" href="structGeometry_1_1Intersection.html#a3a5657af0debf92f5653e1f7627ce417" title="Edges are identical.">identical</a>=<span class="keyword">true</span>;
<a name="l00239"></a>00239         out.<a class="code" href="structGeometry_1_1Intersection.html#aad30a67c865aca570fff7f29a9251903" title="Edges are parallel.">parallel</a>=<span class="keyword">true</span>;
<a name="l00240"></a>00240         out.<a class="code" href="structGeometry_1_1Intersection.html#a468bd7fe9703f6bd57aabbd0d957668e" title="Edges are collinear (and thus also parallel).">collinear</a>=<span class="keyword">true</span>;
<a name="l00241"></a>00241         <span class="keywordflow">return</span> out;
<a name="l00242"></a>00242       }
<a name="l00243"></a>00243     <span class="comment">// Now solve the linear system that returns the</span>
<a name="l00244"></a>00244     <span class="comment">// parametric coordinates of the intersection</span>
<a name="l00245"></a>00245     std::array&lt;std::array&lt;double,2&gt;,2&gt; A;
<a name="l00246"></a>00246     <span class="comment">// to make life easier I call A and B the</span>
<a name="l00247"></a>00247     <span class="comment">// ends of the two segmensts</span>
<a name="l00248"></a>00248     point&lt;2&gt; <span class="keyword">const</span> &amp; A1=Edge1[0];
<a name="l00249"></a>00249     point&lt;2&gt; <span class="keyword">const</span> &amp; B1=Edge1[1];
<a name="l00250"></a>00250     point&lt;2&gt; <span class="keyword">const</span> &amp; A2=Edge2[0];
<a name="l00251"></a>00251     point&lt;2&gt; <span class="keyword">const</span> &amp; B2=Edge2[1];
<a name="l00252"></a>00252     <span class="keyword">auto</span>  V1 = B1-A1;
<a name="l00253"></a>00253     <span class="keyword">auto</span>  V2 = B2-A2;
<a name="l00254"></a>00254     A[0][0]= dot(V1,V1);
<a name="l00255"></a>00255     A[0][1]=-dot(V1,V2);
<a name="l00256"></a>00256     A[1][0]= A[0][1];
<a name="l00257"></a>00257     A[1][1]= dot(V2,V2);
<a name="l00258"></a>00258     std::array&lt;double,2&gt; b;
<a name="l00259"></a>00259     b[0]=    dot(A2-A1,V1);
<a name="l00260"></a>00260     b[1]=    dot(A1-A2,V2);
<a name="l00261"></a>00261     <span class="comment">// find parametric coordinate of the intersection</span>
<a name="l00262"></a>00262     <span class="keyword">auto</span> result=solve(A,b,tol_sys);
<a name="l00263"></a>00263     <span class="comment">// Standard case, the two lines are not parallel</span>
<a name="l00264"></a>00264     <span class="keywordflow">if</span>(result.first==<span class="keyword">true</span>)
<a name="l00265"></a>00265       {
<a name="l00266"></a>00266         <span class="keyword">auto</span> <span class="keyword">const</span> &amp; t = result.second;
<a name="l00267"></a>00267         <span class="comment">// Make a stupid check (only in debugging phase)</span>
<a name="l00268"></a>00268 <span class="preprocessor">#ifndef NDEBUG</span>
<a name="l00269"></a>00269 <span class="preprocessor"></span>        <span class="keyword">auto</span> P1 = A1+ t[0]*(B1-A1);
<a name="l00270"></a>00270         <span class="keyword">auto</span> P2 = A2+ t[1]*(B2-A2);
<a name="l00271"></a>00271         <span class="keywordflow">if</span>(norm(P1-P2)&gt;tol_dist)
<a name="l00272"></a>00272           std::cerr&lt;&lt;<span class="stringliteral">&quot; Something strange, intersection points not coincident. Distance= &quot;</span>&lt;&lt;norm(P1-P2);
<a name="l00273"></a>00273 <span class="preprocessor">#endif        </span>
<a name="l00274"></a>00274 <span class="preprocessor"></span>        <span class="comment">// The two lines intersect.</span>
<a name="l00275"></a>00275         <span class="comment">// Check whether we are inside the segments</span>
<a name="l00276"></a>00276         <span class="keywordtype">double</span> <span class="keyword">const</span> &amp; t1=result.second[0];
<a name="l00277"></a>00277         <span class="keywordtype">double</span> <span class="keyword">const</span> &amp; t2=result.second[1];
<a name="l00278"></a>00278         <span class="comment">//double tol1=tol/len1;</span>
<a name="l00279"></a>00279         <span class="comment">//double tol2=tol/len2;</span>
<a name="l00280"></a>00280         <span class="keywordtype">bool</span> inside =
<a name="l00281"></a>00281           (t1&gt;=-0.5*tol) &amp;&amp; (t1&lt;= 1.0+0.5*tol) &amp;&amp; 
<a name="l00282"></a>00282           (t2&gt;=-0.5*tol) &amp;&amp; (t2&lt;= 1.0+0.5*tol);
<a name="l00283"></a>00283         <span class="keywordflow">if</span> (!inside)
<a name="l00284"></a>00284           {
<a name="l00285"></a>00285             <span class="comment">// No intersecion, end here</span>
<a name="l00286"></a>00286             <span class="keywordflow">return</span> out;
<a name="l00287"></a>00287           }
<a name="l00288"></a>00288         <span class="keywordflow">else</span>
<a name="l00289"></a>00289           {
<a name="l00290"></a>00290             out.<a class="code" href="structGeometry_1_1Intersection.html#a45563c77f618ad3a58931ed051032d45" title="Segments intersects.">intersect</a>=<span class="keyword">true</span>;
<a name="l00291"></a>00291             <span class="comment">// I coud have used the mean</span>
<a name="l00292"></a>00292             <span class="keywordflow">if</span> (std::abs(t1    )&lt;= tol)
<a name="l00293"></a>00293               {
<a name="l00294"></a>00294                 <span class="keywordflow">if</span>(out.<a class="code" href="structGeometry_1_1Intersection.html#ac26994bdf89460be8b13c1304796b6bb">endPointIsIntersection</a>[0][0])
<a name="l00295"></a>00295                   {
<a name="l00296"></a>00296                     <span class="comment">// already found. End here</span>
<a name="l00297"></a>00297                     <span class="keywordflow">return</span> out;
<a name="l00298"></a>00298                   }
<a name="l00299"></a>00299                 <span class="keywordflow">else</span>
<a name="l00300"></a>00300                   {
<a name="l00301"></a>00301                     out.<a class="code" href="structGeometry_1_1Intersection.html#ac26994bdf89460be8b13c1304796b6bb">endPointIsIntersection</a>[0][0]=<span class="keyword">true</span>;
<a name="l00302"></a>00302                   }
<a name="l00303"></a>00303               }
<a name="l00304"></a>00304             <span class="keywordflow">if</span> (std::abs(t1-1.0)&lt;= tol)
<a name="l00305"></a>00305               {
<a name="l00306"></a>00306                 <span class="keywordflow">if</span>(out.<a class="code" href="structGeometry_1_1Intersection.html#ac26994bdf89460be8b13c1304796b6bb">endPointIsIntersection</a>[0][1])
<a name="l00307"></a>00307                   {
<a name="l00308"></a>00308                     <span class="comment">// already found. End here</span>
<a name="l00309"></a>00309                     <span class="keywordflow">return</span> out;
<a name="l00310"></a>00310                   }
<a name="l00311"></a>00311                 <span class="keywordflow">else</span>
<a name="l00312"></a>00312                   {
<a name="l00313"></a>00313                     out.<a class="code" href="structGeometry_1_1Intersection.html#ac26994bdf89460be8b13c1304796b6bb">endPointIsIntersection</a>[0][1]=<span class="keyword">true</span>;
<a name="l00314"></a>00314                   }
<a name="l00315"></a>00315               }
<a name="l00316"></a>00316             <span class="keywordflow">if</span> (std::abs(t2    )&lt;= tol)
<a name="l00317"></a>00317               {
<a name="l00318"></a>00318                 <span class="keywordflow">if</span>(out.<a class="code" href="structGeometry_1_1Intersection.html#ac26994bdf89460be8b13c1304796b6bb">endPointIsIntersection</a>[1][0])
<a name="l00319"></a>00319                   {
<a name="l00320"></a>00320                     <span class="comment">// already found. End here</span>
<a name="l00321"></a>00321                     <span class="keywordflow">return</span> out;
<a name="l00322"></a>00322                   }
<a name="l00323"></a>00323                 <span class="keywordflow">else</span>
<a name="l00324"></a>00324                   {
<a name="l00325"></a>00325                     out.<a class="code" href="structGeometry_1_1Intersection.html#ac26994bdf89460be8b13c1304796b6bb">endPointIsIntersection</a>[1][0]=<span class="keyword">true</span>;
<a name="l00326"></a>00326                   }
<a name="l00327"></a>00327               }
<a name="l00328"></a>00328             <span class="keywordflow">if</span> (std::abs(t2-1.0)&lt;= tol)
<a name="l00329"></a>00329               {
<a name="l00330"></a>00330                 <span class="keywordflow">if</span>(out.<a class="code" href="structGeometry_1_1Intersection.html#ac26994bdf89460be8b13c1304796b6bb">endPointIsIntersection</a>[1][1])
<a name="l00331"></a>00331                   {
<a name="l00332"></a>00332                     <span class="comment">// already found. End here</span>
<a name="l00333"></a>00333                     <span class="keywordflow">return</span> out;
<a name="l00334"></a>00334                 }
<a name="l00335"></a>00335                 <span class="keywordflow">else</span>
<a name="l00336"></a>00336                   {
<a name="l00337"></a>00337                     out.<a class="code" href="structGeometry_1_1Intersection.html#ac26994bdf89460be8b13c1304796b6bb">endPointIsIntersection</a>[1][1]=<span class="keyword">true</span>;
<a name="l00338"></a>00338                   }
<a name="l00339"></a>00339               }
<a name="l00340"></a>00340             out.<a class="code" href="structGeometry_1_1Intersection.html#abd19dce0869cb0e34ce94f48138b8f38" title="Intersection points coordinates.">intersectionPoint</a>[out.<a class="code" href="structGeometry_1_1Intersection.html#a30339c7930808caca3df89da3df2b034" title="Number of intersections (max 2).">numberOfIntersections</a>++]=A1+ t1*(B1-A1);
<a name="l00341"></a>00341             <span class="keywordflow">return</span> out;
<a name="l00342"></a>00342           }
<a name="l00343"></a>00343       }  
<a name="l00344"></a>00344     <span class="keywordflow">else</span>
<a name="l00345"></a>00345       {
<a name="l00346"></a>00346         out.<a class="code" href="structGeometry_1_1Intersection.html#aad30a67c865aca570fff7f29a9251903" title="Edges are parallel.">parallel</a>=<span class="keyword">true</span>;
<a name="l00347"></a>00347       <span class="comment">// Compute distance between the two lines</span>
<a name="l00348"></a>00348       <span class="comment">/*</span>
<a name="l00349"></a>00349 <span class="comment">        (x-Edge1(0,0))(Edge1(1,1)-Edge1(0,1))-(Edge1(1,0)*Edge1(0,0))*(y-Edge1(0,1))=0</span>
<a name="l00350"></a>00350 <span class="comment">        (Edge1(1,1)-Edge1(0,1))x+(Edge1(0,0)*Edge1(1,0))y+Edge1(0,1)(Edge1(1,0)*Edge1(0,0))-</span>
<a name="l00351"></a>00351 <span class="comment">        (Edge1(1,1)-Edge1(0,1))Edge1(0,0)=0</span>
<a name="l00352"></a>00352 <span class="comment">      */</span>
<a name="l00353"></a>00353         <span class="keywordtype">double</span> factor=dot(B1-A1,A2-A1)/(len1*len1);
<a name="l00354"></a>00354         <span class="keyword">auto</span> distVect=
<a name="l00355"></a>00355           (A1-A2) + factor*(B1-A1);
<a name="l00356"></a>00356         <span class="keywordtype">double</span> distance = norm(distVect);
<a name="l00357"></a>00357         out.<a class="code" href="structGeometry_1_1Intersection.html#a08f4c2d8a818d21883e35c932088b6ed" title="Distance, makes sense only if parallel=true.">distance</a>=distance;
<a name="l00358"></a>00358         <span class="comment">// Maybe here you want to use a different tolerance?</span>
<a name="l00359"></a>00359         <span class="keywordflow">if</span> (distance&gt;tol_dist)
<a name="l00360"></a>00360           {
<a name="l00361"></a>00361             <span class="comment">// The two segments are separated</span>
<a name="l00362"></a>00362             <span class="comment">// No intersection.</span>
<a name="l00363"></a>00363             <span class="keywordflow">return</span> out;
<a name="l00364"></a>00364           }
<a name="l00365"></a>00365         <span class="keywordflow">else</span>
<a name="l00366"></a>00366           {
<a name="l00367"></a>00367             out.<a class="code" href="structGeometry_1_1Intersection.html#a468bd7fe9703f6bd57aabbd0d957668e" title="Edges are collinear (and thus also parallel).">collinear</a>=<span class="keyword">true</span>;
<a name="l00368"></a>00368             <span class="keywordtype">double</span> t;
<a name="l00369"></a>00369             <span class="comment">// Segments are collinear!</span>
<a name="l00370"></a>00370             <span class="comment">// We need to consider all the cases!</span>
<a name="l00371"></a>00371             <span class="comment">// IS A2 on Edge1?</span>
<a name="l00372"></a>00372             <span class="comment">// Maybe I have already considered it earlier</span>
<a name="l00373"></a>00373             <span class="keywordflow">if</span>(!out.<a class="code" href="structGeometry_1_1Intersection.html#ac26994bdf89460be8b13c1304796b6bb">endPointIsIntersection</a>[1][0])
<a name="l00374"></a>00374               {
<a name="l00375"></a>00375                 t=dot((A2-A1),(B1-A1))/(len1*len1);
<a name="l00376"></a>00376                 <span class="keywordflow">if</span>(t&gt;=-0.5*tol &amp;&amp; t&lt;=1+0.5*tol)
<a name="l00377"></a>00377                   {
<a name="l00378"></a>00378                     out.<a class="code" href="structGeometry_1_1Intersection.html#a45563c77f618ad3a58931ed051032d45" title="Segments intersects.">intersect</a>=<span class="keyword">true</span>;
<a name="l00379"></a>00379                     out.<a class="code" href="structGeometry_1_1Intersection.html#abd19dce0869cb0e34ce94f48138b8f38" title="Intersection points coordinates.">intersectionPoint</a>[out.<a class="code" href="structGeometry_1_1Intersection.html#a30339c7930808caca3df89da3df2b034" title="Number of intersections (max 2).">numberOfIntersections</a>++]=A2;
<a name="l00380"></a>00380                     out.<a class="code" href="structGeometry_1_1Intersection.html#ac26994bdf89460be8b13c1304796b6bb">endPointIsIntersection</a>[1][0]=<span class="keyword">true</span>;
<a name="l00381"></a>00381                     <span class="keywordflow">if</span>(out.<a class="code" href="structGeometry_1_1Intersection.html#a30339c7930808caca3df89da3df2b034" title="Number of intersections (max 2).">numberOfIntersections</a>==2)<span class="keywordflow">return</span> out;
<a name="l00382"></a>00382                   }
<a name="l00383"></a>00383               }
<a name="l00384"></a>00384             <span class="comment">// IS B2 on Edge1?</span>
<a name="l00385"></a>00385             <span class="comment">// Maybe I have already considered it earlier</span>
<a name="l00386"></a>00386             <span class="keywordflow">if</span>(!out.<a class="code" href="structGeometry_1_1Intersection.html#ac26994bdf89460be8b13c1304796b6bb">endPointIsIntersection</a>[1][1])
<a name="l00387"></a>00387               {
<a name="l00388"></a>00388                 t=dot((B2-A1),(B1-A1))/(len1*len1);
<a name="l00389"></a>00389                 <span class="keywordflow">if</span>(t&gt;=-0.5*tol &amp;&amp; t&lt;=1+0.5*tol)
<a name="l00390"></a>00390                   {
<a name="l00391"></a>00391                     out.<a class="code" href="structGeometry_1_1Intersection.html#a45563c77f618ad3a58931ed051032d45" title="Segments intersects.">intersect</a>=<span class="keyword">true</span>;
<a name="l00392"></a>00392                     out.<a class="code" href="structGeometry_1_1Intersection.html#abd19dce0869cb0e34ce94f48138b8f38" title="Intersection points coordinates.">intersectionPoint</a>[out.<a class="code" href="structGeometry_1_1Intersection.html#a30339c7930808caca3df89da3df2b034" title="Number of intersections (max 2).">numberOfIntersections</a>++]=B2;
<a name="l00393"></a>00393                     out.<a class="code" href="structGeometry_1_1Intersection.html#ac26994bdf89460be8b13c1304796b6bb">endPointIsIntersection</a>[1][1]=<span class="keyword">true</span>;
<a name="l00394"></a>00394                     <span class="keywordflow">if</span>(out.<a class="code" href="structGeometry_1_1Intersection.html#a30339c7930808caca3df89da3df2b034" title="Number of intersections (max 2).">numberOfIntersections</a>==2)<span class="keywordflow">return</span> out;
<a name="l00395"></a>00395                   }
<a name="l00396"></a>00396               }
<a name="l00397"></a>00397             <span class="comment">// IS A1 on Edge2?</span>
<a name="l00398"></a>00398             <span class="comment">// Maybe I have already considered it earlier</span>
<a name="l00399"></a>00399             <span class="keywordflow">if</span>(!out.<a class="code" href="structGeometry_1_1Intersection.html#ac26994bdf89460be8b13c1304796b6bb">endPointIsIntersection</a>[0][0])
<a name="l00400"></a>00400               {
<a name="l00401"></a>00401                 t=dot((A1-A2),(B2-A2))/(len2*len2);
<a name="l00402"></a>00402                 <span class="keywordflow">if</span>(t&gt;=-0.5*tol &amp;&amp; t&lt;=1+0.5*tol)
<a name="l00403"></a>00403                   {
<a name="l00404"></a>00404                     out.<a class="code" href="structGeometry_1_1Intersection.html#a45563c77f618ad3a58931ed051032d45" title="Segments intersects.">intersect</a>=<span class="keyword">true</span>;
<a name="l00405"></a>00405                     out.<a class="code" href="structGeometry_1_1Intersection.html#abd19dce0869cb0e34ce94f48138b8f38" title="Intersection points coordinates.">intersectionPoint</a>[out.<a class="code" href="structGeometry_1_1Intersection.html#a30339c7930808caca3df89da3df2b034" title="Number of intersections (max 2).">numberOfIntersections</a>++]=A1;
<a name="l00406"></a>00406                     out.<a class="code" href="structGeometry_1_1Intersection.html#ac26994bdf89460be8b13c1304796b6bb">endPointIsIntersection</a>[0][0]=<span class="keyword">true</span>;
<a name="l00407"></a>00407                     <span class="keywordflow">if</span>(out.<a class="code" href="structGeometry_1_1Intersection.html#a30339c7930808caca3df89da3df2b034" title="Number of intersections (max 2).">numberOfIntersections</a>==2)<span class="keywordflow">return</span> out;
<a name="l00408"></a>00408                   }
<a name="l00409"></a>00409               }
<a name="l00410"></a>00410             <span class="comment">// IS B1 on Edge2?</span>
<a name="l00411"></a>00411             <span class="comment">// Maybe I have already considered it earlier</span>
<a name="l00412"></a>00412             <span class="keywordflow">if</span>(!out.<a class="code" href="structGeometry_1_1Intersection.html#ac26994bdf89460be8b13c1304796b6bb">endPointIsIntersection</a>[0][1])
<a name="l00413"></a>00413               {
<a name="l00414"></a>00414                 t=dot((B1-A2),(B2-A2))/(len2*len2);
<a name="l00415"></a>00415                 <span class="keywordflow">if</span>(t&gt;=-0.5*tol &amp;&amp; t&lt;=1+0.5*tol)
<a name="l00416"></a>00416                   {
<a name="l00417"></a>00417                     out.<a class="code" href="structGeometry_1_1Intersection.html#a45563c77f618ad3a58931ed051032d45" title="Segments intersects.">intersect</a>=<span class="keyword">true</span>;
<a name="l00418"></a>00418                     out.<a class="code" href="structGeometry_1_1Intersection.html#abd19dce0869cb0e34ce94f48138b8f38" title="Intersection points coordinates.">intersectionPoint</a>[out.<a class="code" href="structGeometry_1_1Intersection.html#a30339c7930808caca3df89da3df2b034" title="Number of intersections (max 2).">numberOfIntersections</a>++]=B1;
<a name="l00419"></a>00419                     out.<a class="code" href="structGeometry_1_1Intersection.html#ac26994bdf89460be8b13c1304796b6bb">endPointIsIntersection</a>[0][1]=<span class="keyword">true</span>;
<a name="l00420"></a>00420                     <span class="keywordflow">if</span>(out.<a class="code" href="structGeometry_1_1Intersection.html#a30339c7930808caca3df89da3df2b034" title="Number of intersections (max 2).">numberOfIntersections</a>==2)<span class="keywordflow">return</span> out;
<a name="l00421"></a>00421                   }
<a name="l00422"></a>00422               }
<a name="l00423"></a>00423           }
<a name="l00424"></a>00424       }
<a name="l00425"></a>00425     <span class="keywordflow">return</span> out;                                         
<a name="l00426"></a>00426         }       <span class="comment">//xompute_intersection</span>
<a name="l00427"></a>00427         
<a name="l00431"></a>00431         std::ostream &amp; operator &lt;&lt; (std::ostream &amp; out, <a class="code" href="structGeometry_1_1Intersection.html" title="A simple struct that contains the result of the intersection test.">Geometry::Intersection</a> <span class="keyword">const</span> &amp; i){
<a name="l00432"></a>00432                 out&lt;&lt;<span class="stringliteral">&quot;*Segment intersections:&quot;</span>&lt;&lt;std::endl;
<a name="l00433"></a>00433                 out&lt;&lt;<span class="stringliteral">&quot;\tSegment intersects     :&quot;</span>&lt;&lt;std::boolalpha&lt;&lt;i.<a class="code" href="structGeometry_1_1Intersection.html#a45563c77f618ad3a58931ed051032d45" title="Segments intersects.">intersect</a>&lt;&lt;std::endl;
<a name="l00434"></a>00434                 <span class="keywordflow">if</span> (!i.<a class="code" href="structGeometry_1_1Intersection.html#a45563c77f618ad3a58931ed051032d45" title="Segments intersects.">intersect</a>) <span class="keywordflow">return</span> out;
<a name="l00435"></a>00435                 out&lt;&lt;<span class="stringliteral">&quot;\tNumber of intersections:&quot;</span>&lt;&lt;i.<a class="code" href="structGeometry_1_1Intersection.html#a30339c7930808caca3df89da3df2b034" title="Number of intersections (max 2).">numberOfIntersections</a>&lt;&lt;std::endl;
<a name="l00436"></a>00436                 <span class="keywordflow">for</span> (<span class="keyword">auto</span> j=0u;j&lt;i.<a class="code" href="structGeometry_1_1Intersection.html#a30339c7930808caca3df89da3df2b034" title="Number of intersections (max 2).">numberOfIntersections</a>;++j)
<a name="l00437"></a>00437                 {
<a name="l00438"></a>00438                     out&lt;&lt;<span class="stringliteral">&quot;\t x[&quot;</span>&lt;&lt;j&lt;&lt;<span class="stringliteral">&quot;]=&quot;</span>&lt;&lt;i.<a class="code" href="structGeometry_1_1Intersection.html#abd19dce0869cb0e34ce94f48138b8f38" title="Intersection points coordinates.">intersectionPoint</a>[j][0];
<a name="l00439"></a>00439                     out&lt;&lt;<span class="stringliteral">&quot;\t y[&quot;</span>&lt;&lt;j&lt;&lt;<span class="stringliteral">&quot;]=&quot;</span>&lt;&lt;i.<a class="code" href="structGeometry_1_1Intersection.html#abd19dce0869cb0e34ce94f48138b8f38" title="Intersection points coordinates.">intersectionPoint</a>[j][1];
<a name="l00440"></a>00440                     out&lt;&lt;std::endl;
<a name="l00441"></a>00441                 }
<a name="l00442"></a>00442                 out&lt;&lt;<span class="stringliteral">&quot;\t Segments are identical:&quot;</span>&lt;&lt;std::boolalpha&lt;&lt;i.<a class="code" href="structGeometry_1_1Intersection.html#a3a5657af0debf92f5653e1f7627ce417" title="Edges are identical.">identical</a>&lt;&lt;std::endl;
<a name="l00443"></a>00443                 out&lt;&lt;<span class="stringliteral">&quot;\t Segments are parallel :&quot;</span>&lt;&lt;std::boolalpha&lt;&lt;i.<a class="code" href="structGeometry_1_1Intersection.html#aad30a67c865aca570fff7f29a9251903" title="Edges are parallel.">parallel</a>&lt;&lt;std::endl;
<a name="l00444"></a>00444                 out&lt;&lt;<span class="stringliteral">&quot;\t Segments are collinear:&quot;</span>&lt;&lt;std::boolalpha&lt;&lt;i.<a class="code" href="structGeometry_1_1Intersection.html#a468bd7fe9703f6bd57aabbd0d957668e" title="Edges are collinear (and thus also parallel).">collinear</a>&lt;&lt;std::endl;
<a name="l00445"></a>00445                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0u;j&lt;2;++j)
<a name="l00446"></a>00446                 {
<a name="l00447"></a>00447                     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0u;k&lt;2;++k)
<a name="l00448"></a>00448                     {
<a name="l00449"></a>00449                         <span class="keywordflow">if</span>(i.<a class="code" href="structGeometry_1_1Intersection.html#ac26994bdf89460be8b13c1304796b6bb">endPointIsIntersection</a>[j][k])
<a name="l00450"></a>00450                         {
<a name="l00451"></a>00451                             out&lt;&lt;<span class="stringliteral">&quot;\t EndPoint &quot;</span>&lt;&lt;k&lt;&lt;<span class="stringliteral">&quot; of segment &quot;</span>&lt;&lt;j&lt;&lt;<span class="stringliteral">&quot; is intersection&quot;</span>&lt;&lt;std::endl;
<a name="l00452"></a>00452                             <span class="keywordflow">if</span>(i.<a class="code" href="structGeometry_1_1Intersection.html#a15cd54d14fc1ddc1f4499dc49e1d5508">otherEdgePoint</a>[j][k]!=-1)
<a name="l00453"></a>00453                             out&lt;&lt;<span class="stringliteral">&quot;\t\t and it is joined to EdgePoint &quot;</span>&lt;&lt;i.<a class="code" href="structGeometry_1_1Intersection.html#a15cd54d14fc1ddc1f4499dc49e1d5508">otherEdgePoint</a>[j][k]
<a name="l00454"></a>00454                                 &lt;&lt;<span class="stringliteral">&quot; of segment &quot;</span>&lt;&lt;j+1 %2&lt;&lt;std::endl;
<a name="l00455"></a>00455                         }
<a name="l00456"></a>00456                     }               
<a name="l00457"></a>00457                 }
<a name="l00458"></a>00458                 <span class="keywordflow">return</span> out;
<a name="l00459"></a>00459         }               <span class="comment">//operator&lt;&lt;    </span>
<a name="l00460"></a>00460         
<a name="l00461"></a>00461 }       <span class="comment">//BGLgeom</span>
<a name="l00462"></a>00462 
<a name="l00463"></a>00463 
<a name="l00464"></a>00464 
<a name="l00465"></a>00465 
<a name="l00466"></a>00466 
<a name="l00467"></a>00467 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Graph&gt;
<a name="l00468"></a><a class="code" href="classintersector__base__class.html">00468</a> <span class="keyword">class </span><a class="code" href="classintersector__base__class.html">intersector_base_class</a> {
<a name="l00469"></a>00469         <span class="keyword">public</span>:
<a name="l00470"></a>00470         
<a name="l00471"></a>00471                 <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::graph_traits&lt;Graph&gt;::edge_descriptor Edge_desc;
<a name="l00472"></a>00472                 <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::graph_traits&lt;Graph&gt;::edge_iterator Edge_iter;
<a name="l00473"></a>00473                 <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::graph_traits&lt;Graph&gt;::vertex_descriptor Vertex_desc;
<a name="l00474"></a>00474                 <span class="keyword">typedef</span> std::pair&lt;point&lt;2&gt;, point&lt;2&gt; &gt; Line;
<a name="l00475"></a>00475                 <span class="keyword">typedef</span> <span class="keyword">typename</span> std::vector&lt;std::pair&lt;point&lt;2&gt;, Edge_desc&gt; &gt; Intersections_type;
<a name="l00476"></a>00476                 <span class="keyword">typedef</span> <span class="keyword">typename</span> std::pair&lt;point&lt;2&gt;, Edge_desc&gt; Intersections_value_type;
<a name="l00477"></a>00477                 
<a name="l00479"></a><a class="code" href="classintersector__base__class.html#a8d13a4f8f6dec439866977a5b4fb0795">00479</a>                 <a class="code" href="classintersector__base__class.html#a8d13a4f8f6dec439866977a5b4fb0795" title="Default constructor (initialization of the reference to the graph needed).">intersector_base_class</a>():       
<a name="l00480"></a>00480                                                                                         Edge1(),
<a name="l00481"></a>00481                                                                                         Edge2(),
<a name="l00482"></a>00482                                                                                         <a class="code" href="classintersector__base__class.html#a519ee3535c9e7aaf97a547413ebe0b08" title="Vector that will contains the intersection point and the edge descriptor of the edge...">intersections</a>(),
<a name="l00483"></a>00483                                                                                         <a class="code" href="classintersector__base__class.html#a13c90acea49e8fef960046229a68e8b6" title="The intersection point between Edge1 and Edge2 (if present).">intersection_point</a>(),
<a name="l00484"></a>00484                                                                                         <a class="code" href="classintersector__base__class.html#a87fabe1d84ba485f04a46d5202e7bf23" title="Edge descriptor of Edge2.  If the user has to perform multiple intersections between...">Edge2_descriptor</a>() {};
<a name="l00485"></a>00485 
<a name="l00487"></a>00487                 <a class="code" href="classintersector__base__class.html#a8d13a4f8f6dec439866977a5b4fb0795" title="Default constructor (initialization of the reference to the graph needed).">intersector_base_class</a>(<a class="code" href="classintersector__base__class.html">intersector_base_class</a> <span class="keyword">const</span>&amp;) = <span class="keywordflow">default</span>;
<a name="l00488"></a>00488                 
<a name="l00490"></a><a class="code" href="classintersector__base__class.html#aeca93030cff57166c7b70b2911a7bddf">00490</a>                 <span class="keyword">virtual</span> <a class="code" href="classintersector__base__class.html#aeca93030cff57166c7b70b2911a7bddf" title="Destructor.">~intersector_base_class</a>(){};
<a name="l00491"></a>00491                 
<a name="l00493"></a>00493                 <a class="code" href="classintersector__base__class.html">intersector_base_class</a> &amp; <a class="code" href="classintersector__base__class.html#a3486613036aada6bf7174f158282649b" title="Assignment operator.">operator=</a>(<a class="code" href="classintersector__base__class.html">intersector_base_class</a> <span class="keyword">const</span>&amp;) = <span class="keywordflow">default</span>;
<a name="l00494"></a>00494                 
<a name="l00495"></a>00495                 <span class="comment">//======================= ATTRIBUTES SETTING OPERATIONS ====================</span>
<a name="l00496"></a>00496                 
<a name="l00498"></a><a class="code" href="classintersector__base__class.html#a6c8fee82915c3745f41ffb5b714bda1c">00498</a>                 <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classintersector__base__class.html#a6c8fee82915c3745f41ffb5b714bda1c" title="It sets Edge1 from two points.">set_Edge1</a>(point&lt;2&gt; <span class="keyword">const</span>&amp; P1, point&lt;2&gt; <span class="keyword">const</span>&amp; P2){
<a name="l00499"></a>00499                         Edge1 = std::make_pair(P1,P2);
<a name="l00500"></a>00500                 };
<a name="l00501"></a>00501                 
<a name="l00503"></a><a class="code" href="classintersector__base__class.html#a789a58d61926fc4f2b5fc096f355633b">00503</a>                 <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classintersector__base__class.html#a789a58d61926fc4f2b5fc096f355633b" title="It sets Edge1 from another Line.">set_Edge1</a>(Line _L){
<a name="l00504"></a>00504                         Edge1 = _L;
<a name="l00505"></a>00505                 };
<a name="l00506"></a>00506                 
<a name="l00508"></a><a class="code" href="classintersector__base__class.html#a60fe2748b57d0004d51e2ab0d8499401">00508</a>                 <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classintersector__base__class.html#a60fe2748b57d0004d51e2ab0d8499401" title="It sets Edge2 from two points.">set_Edge2</a>(point&lt;2&gt; <span class="keyword">const</span>&amp; P1, point&lt;2&gt; <span class="keyword">const</span>&amp; P2){
<a name="l00509"></a>00509                         Edge2 = std::make_pair(P1,P2);
<a name="l00510"></a>00510                 };
<a name="l00511"></a>00511                 
<a name="l00513"></a><a class="code" href="classintersector__base__class.html#a9388c8ba39f252ce90ba27958c212bdc">00513</a>                 <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classintersector__base__class.html#a9388c8ba39f252ce90ba27958c212bdc" title="It sets Edge1 from another Line.">set_Edge2</a>(Line _L){
<a name="l00514"></a>00514                         Edge2 = _L;
<a name="l00515"></a>00515                 };
<a name="l00516"></a>00516                 
<a name="l00518"></a><a class="code" href="classintersector__base__class.html#ae7956127e010d767ade9529a977ac860">00518</a>                 <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classintersector__base__class.html#ae7956127e010d767ade9529a977ac860" title="It allows to set Edge2_descriptor.">set_Edge2_descriptor</a>(Edge_desc _Edge2_desc){
<a name="l00519"></a>00519                         <a class="code" href="classintersector__base__class.html#a87fabe1d84ba485f04a46d5202e7bf23" title="Edge descriptor of Edge2.  If the user has to perform multiple intersections between...">Edge2_descriptor</a> = _Edge2_desc;
<a name="l00520"></a>00520                 };
<a name="l00521"></a>00521                 
<a name="l00522"></a>00522                 <span class="comment">//================ INTERSECTION OPERATIONS ======================</span>
<a name="l00523"></a>00523                 
<a name="l00529"></a>00529                 <span class="comment">// Qui ci andrà la funzione di formaggia e non sarà più abstract!</span>
<a name="l00530"></a>00530                 <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classintersector__base__class.html#a228d28f80f13bf02b88f02a8d015c6a0" title="It checks if Edge1 and Edge2 are actually intersected  If the two edge are intersecating...">are_intersected</a>() = 0;
<a name="l00531"></a>00531                 
<a name="l00533"></a><a class="code" href="classintersector__base__class.html#aac491cba39ea4dc1abe943a007b62de9">00533</a>                 <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classintersector__base__class.html#aac491cba39ea4dc1abe943a007b62de9" title="It pushes back a new intersection point between Edge1 and Edge2, remembering the...">store_intersection</a>(){
<a name="l00534"></a>00534                         <a class="code" href="classintersector__base__class.html#a519ee3535c9e7aaf97a547413ebe0b08" title="Vector that will contains the intersection point and the edge descriptor of the edge...">intersections</a>.push_back(std::make_pair(<a class="code" href="classintersector__base__class.html#a13c90acea49e8fef960046229a68e8b6" title="The intersection point between Edge1 and Edge2 (if present).">intersection_point</a>, <a class="code" href="classintersector__base__class.html#a87fabe1d84ba485f04a46d5202e7bf23" title="Edge descriptor of Edge2.  If the user has to perform multiple intersections between...">Edge2_descriptor</a>));  
<a name="l00535"></a>00535                 };      <span class="comment">//compute_intersections</span>
<a name="l00536"></a>00536                 
<a name="l00537"></a>00537                 <span class="keyword">virtual</span> <span class="keywordtype">void</span> clear_intersections(){
<a name="l00538"></a>00538                         <a class="code" href="classintersector__base__class.html#a519ee3535c9e7aaf97a547413ebe0b08" title="Vector that will contains the intersection point and the edge descriptor of the edge...">intersections</a>.clear();
<a name="l00539"></a>00539                 };
<a name="l00540"></a>00540                 
<a name="l00546"></a>00546                 <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classintersector__base__class.html#a50ea9691038f34ac8dae9f80af5e8fb6" title="It explains how to rebuilt graph after the intersections were computed  It has to...">refine_graph</a>() = 0;
<a name="l00547"></a>00547                 
<a name="l00548"></a>00548                 <span class="comment">//===================== SORTING UTILITIES =============================//</span>
<a name="l00549"></a>00549                 
<a name="l00555"></a>00555                 <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classintersector__base__class.html#ac7266d33ff6840e07837ed3247ef3de7" title="This reorders the vector intersections according to some order, defined by the user...">order_intersections</a>() = 0;
<a name="l00556"></a>00556                 
<a name="l00557"></a>00557                 <span class="comment">//Not provided methods to give ordering, because it wouldn&apos;t work inside a std::sort. Use lambda functions instead</span>
<a name="l00558"></a>00558 
<a name="l00559"></a>00559         <span class="keyword">protected</span>:
<a name="l00560"></a>00560                 <span class="comment">//Non ho bisogno del grafo in realtà, qua si gestiscono solo le operazioni geometriche tra due edge qualsiasi, nn su tt il grafo</span>
<a name="l00561"></a>00561                 
<a name="l00567"></a><a class="code" href="classintersector__base__class.html#a9d52bda5a4eae76968f8cac57d055c41">00567</a>                 Line Edge1;
<a name="l00573"></a><a class="code" href="classintersector__base__class.html#af568953d08cce423eda95e4a7fbe1ecf">00573</a>                 Line Edge2;
<a name="l00575"></a><a class="code" href="classintersector__base__class.html#a519ee3535c9e7aaf97a547413ebe0b08">00575</a>                 Intersections_type <a class="code" href="classintersector__base__class.html#a519ee3535c9e7aaf97a547413ebe0b08" title="Vector that will contains the intersection point and the edge descriptor of the edge...">intersections</a>;
<a name="l00577"></a><a class="code" href="classintersector__base__class.html#a13c90acea49e8fef960046229a68e8b6">00577</a>                 point&lt;2&gt; <a class="code" href="classintersector__base__class.html#a13c90acea49e8fef960046229a68e8b6" title="The intersection point between Edge1 and Edge2 (if present).">intersection_point</a>;
<a name="l00584"></a><a class="code" href="classintersector__base__class.html#a87fabe1d84ba485f04a46d5202e7bf23">00584</a>                 Edge_desc <a class="code" href="classintersector__base__class.html#a87fabe1d84ba485f04a46d5202e7bf23" title="Edge descriptor of Edge2.  If the user has to perform multiple intersections between...">Edge2_descriptor</a>;
<a name="l00585"></a>00585                 
<a name="l00586"></a>00586 };      <span class="comment">//intersector_base_class</span>
<a name="l00587"></a>00587 
<a name="l00588"></a>00588 <span class="preprocessor">#endif  //HH_INTERSECTOR_BASE_CLASS_HH</span>
</pre></div></div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 24 Oct 2016 for BGL Interface by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
