<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BGL Interface: include/maximum_flow_imp.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>include/maximum_flow_imp.hpp File Reference</h1>
<p>Implementations of the functions defined in <a class="el" href="maximum__flow_8hpp.html" title="Header file for managing maximum_flow algorithm from BGL.">maximum_flow.hpp</a>.  
<a href="#_details">More...</a></p>

<p><a href="maximum__flow__imp_8hpp_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Graph , typename Edge_Descriptor_g &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">double&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="maximum__flow__imp_8hpp.html#a96c43e089d974ef6e94a5e939159f4b4">maximum_flow</a> (Graph const &amp;G, typename boost::graph_traits&lt; Graph &gt;::vertex_descriptor s, typename boost::graph_traits&lt; Graph &gt;::vertex_descriptor t, std::map&lt; Edge_Descriptor_g, double &gt; &amp;out_residual_capacity)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">It runs push_relabel_max_flow algorithm on graph G.  <a href="#a96c43e089d974ef6e94a5e939159f4b4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Graph , typename Flow_Graph , typename Edge_fg &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="maximum__flow__imp_8hpp.html#a9eb280b278f5c68bf857146abfbb0578">build_flow_graph</a> (Graph const &amp;G, Flow_Graph &amp;FG, std::map&lt; Edge_fg, Edge_fg &gt; &amp;rev_map)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function for maximum_flow.  <a href="#a9eb280b278f5c68bf857146abfbb0578"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Graph , typename Flow_Graph , typename Edge_Descriptor_g &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="maximum__flow__imp_8hpp.html#a4fa083772791ed469ba5786aeb3a619e">store_residual_capacity</a> (Graph const &amp;G, Flow_Graph const &amp;FG, std::map&lt; Edge_Descriptor_g, double &gt; &amp;out_residual_capacity)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function that stores residual capacity on edges after computation of max flow.  <a href="#a4fa083772791ed469ba5786aeb3a619e"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Implementations of the functions defined in <a class="el" href="maximum__flow_8hpp.html" title="Header file for managing maximum_flow algorithm from BGL.">maximum_flow.hpp</a>. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Ilaria Speranza &amp; Mattia Tantardini </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>Sep 14, 2016 </dd></dl>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a9eb280b278f5c68bf857146abfbb0578"></a><!-- doxytag: member="maximum_flow_imp.hpp::build_flow_graph" ref="a9eb280b278f5c68bf857146abfbb0578" args="(Graph const &amp;G, Flow_Graph &amp;FG, std::map&lt; Edge_fg, Edge_fg &gt; &amp;rev_map)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph , typename Flow_Graph , typename Edge_fg &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void build_flow_graph </td>
          <td>(</td>
          <td class="paramtype">Graph const &amp;&nbsp;</td>
          <td class="paramname"> <em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Flow_Graph &amp;&nbsp;</td>
          <td class="paramname"> <em>FG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; Edge_fg, Edge_fg &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rev_map</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper function for maximum_flow. </p>
<p>This function build the flow graph associated to the input graph. This is because we want not to modify the original Graph passed as input in maximum_flow, and because the push_relabelmax_flow algorithm requires such a Graph. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>G</em>&nbsp;</td><td>Graph </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FG</em>&nbsp;</td><td>Flow graph that will be built inside the function. We need to build a new graph with a special structure in order to accomplish the requirments of boost::push_relabel_max_flow </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rev_map</em>&nbsp;</td><td>Map that stores the reverse edge for each edge in the graph. It is needed to build Flow Graph. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a96c43e089d974ef6e94a5e939159f4b4"></a><!-- doxytag: member="maximum_flow_imp.hpp::maximum_flow" ref="a96c43e089d974ef6e94a5e939159f4b4" args="(Graph const &amp;G, typename boost::graph_traits&lt; Graph &gt;::vertex_descriptor s, typename boost::graph_traits&lt; Graph &gt;::vertex_descriptor t, std::map&lt; Edge_Descriptor_g, double &gt; &amp;out_residual_capacity)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph , typename Edge_Descriptor_g &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double maximum_flow </td>
          <td>(</td>
          <td class="paramtype">Graph const &amp;&nbsp;</td>
          <td class="paramname"> <em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename boost::graph_traits&lt; Graph &gt;::vertex_descriptor&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename boost::graph_traits&lt; Graph &gt;::vertex_descriptor&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; Edge_Descriptor_g, double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>out_residual_capacity</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>It runs push_relabel_max_flow algorithm on graph G. </p>
<p>This function find the maximum flow that can flow from node s to node t.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>G</em>&nbsp;</td><td>Graph </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>Source vertex chosen for the maximum flow problem </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>Target vertex chosen for the maximum flow problem </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>out_residual_capacity</em>&nbsp;</td><td>Map that stores the residual capacity left in each edge </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4fa083772791ed469ba5786aeb3a619e"></a><!-- doxytag: member="maximum_flow_imp.hpp::store_residual_capacity" ref="a4fa083772791ed469ba5786aeb3a619e" args="(Graph const &amp;G, Flow_Graph const &amp;FG, std::map&lt; Edge_Descriptor_g, double &gt; &amp;out_residual_capacity)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph , typename Flow_Graph , typename Edge_Descriptor_g &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void store_residual_capacity </td>
          <td>(</td>
          <td class="paramtype">Graph const &amp;&nbsp;</td>
          <td class="paramname"> <em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Flow_Graph const &amp;&nbsp;</td>
          <td class="paramname"> <em>FG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; Edge_Descriptor_g, double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>out_residual_capacity</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper function that stores residual capacity on edges after computation of max flow. </p>
<p>We use a vector. Next step: using a map&lt;Edge_descriptor, residual_capacity_value&gt; This function search in the flow graph which edges have the same sources and target as the edges in G, so that we can associate the right residual capacity to the right original edge of G. This is because FG is a utility in order to run the push_relabel algorithm and it is destroied after exiting this function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>G</em>&nbsp;</td><td>Graph </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FG</em>&nbsp;</td><td>Flow Graph </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>out_residual_capacity</em>&nbsp;</td><td>Map that stores the residual capacity left in each edge </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 24 Oct 2016 for BGL Interface by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
