{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\comment Begining font list}
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\comment begin colors}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}
{\comment Beginning style list}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 9;}
{\s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext51 List Continue 0;}
{\s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext52 List Continue 1;}
{\s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext53 List Continue 2;}
{\s53\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext54 List Continue 3;}
{\s54\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext55 List Continue 4;}
{\s55\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext56 List Continue 5;}
{\s56\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext57 List Continue 6;}
{\s57\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext58 List Continue 7;}
{\s58\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 8;}
{\s59\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 9;}
{\s60\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext61 DescContinue 0;}
{\s61\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext62 DescContinue 1;}
{\s62\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext63 DescContinue 2;}
{\s63\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext64 DescContinue 3;}
{\s64\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext65 DescContinue 4;}
{\s65\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext66 DescContinue 5;}
{\s66\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext67 DescContinue 6;}
{\s67\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext68 DescContinue 7;}
{\s68\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 8;}
{\s69\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 9;}
{\s70\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext81 LatexTOC 0;}
{\s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext82 LatexTOC 1;}
{\s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext83 LatexTOC 2;}
{\s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext84 LatexTOC 3;}
{\s74\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext85 LatexTOC 4;}
{\s75\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext86 LatexTOC 5;}
{\s76\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext87 LatexTOC 6;}
{\s77\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext88 LatexTOC 7;}
{\s78\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 8;}
{\s79\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 9;}
{\s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext81 \sautoupd List Bullet 0;}
{\s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid \sbasedon0 \snext82 \sautoupd List Bullet 1;}
{\s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid \sbasedon0 \snext83 \sautoupd List Bullet 2;}
{\s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid \sbasedon0 \snext84 \sautoupd List Bullet 3;}
{\s84\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls5\adjustright \fs20\cgrid \sbasedon0 \snext85 \sautoupd List Bullet 4;}
{\s85\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls6\adjustright \fs20\cgrid \sbasedon0 \snext86 \sautoupd List Bullet 5;}
{\s86\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls7\adjustright \fs20\cgrid \sbasedon0 \snext87 \sautoupd List Bullet 6;}
{\s87\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls8\adjustright \fs20\cgrid \sbasedon0 \snext88 \sautoupd List Bullet 7;}
{\s88\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls9\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 8;}
{\s89\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls10\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 9;}
{\s90\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext91 \sautoupd List Enum 0;}
{\s91\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext92 \sautoupd List Enum 1;}
{\s92\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext93 \sautoupd List Enum 2;}
{\s93\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext94 \sautoupd List Enum 3;}
{\s94\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext95 \sautoupd List Enum 4;}
{\s95\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s96\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s97\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext98 \sautoupd List Enum 7;}
{\s98\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 8;}
{\s99\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 9;}
}
{\comment begin body}
{\info 
{\title {\comment BGL Interface }BGL Interface}
{\comment Generated byDoxgyen. }
{\creatim \yr2016\mo10\dy24\hr17\min21\sec34}
}{\comment end of infoblock}
\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
{\comment begin title page}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt TITLE}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version \par{\field\fldedit {\*\fldinst CREATEDATE \\*MERGEFORMAT}{\fldrslt CREATEDATE}}\par
\page\page{\comment End title page}
{\comment Table of contents}
\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
{\comment Beginning Body of RTF Document}
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

{\comment BeginRTFChapter}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Todo List{\tc \v Todo List}\par \pard\plain 
{\comment writeAnchor (todo)}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
\par \pard\plain 
{\comment begin include todo.rtf}
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
 {\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Class {\b Geometry::Intersection}  \par
}
{\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid It can be bettered by adding another attribute that indicates, in the case of two edges end which coincides the relative position on the edge. It requires a simple modification of the function segmentIntersect \par}
}{\comment endTextBlock}
}
{\comment endFile}
{\comment end include todo.rtf}
{\comment start classhierarchy}

{\comment BeginRTFChapter}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Index\par \pard\plain 
{\tc \v Hierarchical Index}
{\comment begin include hierarchy.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class Hierarchy{\comment endTitleHead}
\par \pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This inheritance list is sorted roughly, but not completely, alphabetically:{\comment endTextBlock}
}
{\comment (startIndexList)}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\comment (startIndexItem)}
circular_edge_geometry{\comment (endIndexItem)}
\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACR \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (startIndexItem)}
data_structure< Edge_data_structure, Vertex_data_structure >{\comment (endIndexItem)}
\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACS \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (startIndexItem)}
edge_data_structure< dim >{\comment (endIndexItem)}
\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACT \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (startIndexItem)}
BGLgeom::edge_geometry< dim >{\comment (endIndexItem)}
\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACU \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (startIndexList)}
{
\par
\pard\plain \s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\comment (startIndexItem)}
BGLgeom::generic_edge_geometry< dim >{\comment (endIndexItem)}
\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADA \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (endIndexList)}
}{\comment (startIndexItem)}
edge_parametrization{\comment (endIndexItem)}
\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACV \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (startIndexItem)}
edge_prop_max_flow_t{\comment (endIndexItem)}
\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACW \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (startIndexItem)}
Forma_edge_property_t{\comment (endIndexItem)}
\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACY \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (startIndexItem)}
Forma_vertex_property_t{\comment (endIndexItem)}
\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACZ \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (startIndexItem)}
Geometry::Intersection{\comment (endIndexItem)}
\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADB \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (startIndexItem)}
intersector_base_class< Graph >{\comment (endIndexItem)}
\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADC \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (startIndexList)}
{
\par
\pard\plain \s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\comment (startIndexItem)}
final< Graph >{\comment (endIndexItem)}
\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACX \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (endIndexList)}
}{\comment (startIndexItem)}
Geometry::Linear_edge{\comment (endIndexItem)}
\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADD \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (startIndexItem)}
my_edge{\comment (endIndexItem)}
\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADE \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (startIndexItem)}
new_reader_class< Source_data_structure, Target_data_structure, Edge_data_structure, Topological_data_structure >{\comment (endIndexItem)}
\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADF \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (startIndexItem)}
new_reader_class< Zunino_source_data, Zunino_target_data, Zunino_edge_data, Zunino_topological_data >{\comment (endIndexItem)}
\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADF \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (startIndexList)}
{
\par
\pard\plain \s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\comment (startIndexItem)}
Zunino_reader< Zunino_source_data, Zunino_target_data, Zunino_edge_data, Zunino_topological_data >{\comment (endIndexItem)}
\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADN \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (endIndexList)}
}{\comment (startIndexItem)}
no_topological_data{\comment (endIndexItem)}
\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADG \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (startIndexItem)}
our_disjoint_sets< Graph >{\comment (endIndexItem)}
\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADH \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (startIndexItem)}
BGLgeom::point< dim, Storage_t >{\comment (endIndexItem)}
\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADI \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (startIndexItem)}
reader_base_class< Graph >{\comment (endIndexItem)}
\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADJ \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (startIndexList)}
{
\par
\pard\plain \s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\comment (startIndexItem)}
final< Graph >{\comment (endIndexItem)}
\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACX \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (startIndexItem)}
final< Graph >{\comment (endIndexItem)}
\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACX \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (endIndexList)}
}{\comment (startIndexItem)}
vertex_data_structure< dim >{\comment (endIndexItem)}
\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADK \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (startIndexItem)}
Zunino_edge_data{\comment (endIndexItem)}
\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADL \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (startIndexItem)}
Zunino_edge_property_t{\comment (endIndexItem)}
\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADM \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (startIndexItem)}
Zunino_source_data{\comment (endIndexItem)}
\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADO \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (startIndexItem)}
Zunino_target_data{\comment (endIndexItem)}
\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADP \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (startIndexItem)}
Zunino_topological_data{\comment (endIndexItem)}
\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADQ \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (endIndexList)}
}{\comment endFile}
{\comment end include hierarchy.rtf}

{\comment BeginRTFChapter}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Index\par \pard\plain 
{\tc \v Class Index}
{\comment begin include annotated.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class List{\comment endTitleHead}
\par \pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the classes, structs, unions and interfaces with brief descriptions:{\comment endTextBlock}
}
{\comment (startIndexList)}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\comment (startIndexKey)}
{\b {\b circular_edge_geometry}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 {\comment (endIndexValue)}
} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACR \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (startIndexKey)}
{\b {\b data_structure< Edge_data_structure, Vertex_data_structure >}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An abstract class to handle the user definition data structure  The users has to specify, in the derived class, all variables he need in order to store information read from the input file. Then, through the definition of Edge_data_structure and Vertex_data_structure, he can get separately all the information to put on edges and vertices }{\comment (endIndexValue)}
)} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACS \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (startIndexKey)}
{\b {\b edge_data_structure< dim >}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 {\comment (endIndexValue)}
} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACT \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (startIndexKey)}
{\b {\b BGLgeom::edge_geometry< dim >}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 {\comment (endIndexValue)}
} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACU \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (startIndexKey)}
{\b {\b edge_parametrization}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class holds the parametrization of the edge }{\comment (endIndexValue)}
)} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACV \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (startIndexKey)}
{\b {\b edge_prop_max_flow_t}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 {\comment (endIndexValue)}
} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACW \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (startIndexKey)}
{\b {\b final< Graph >}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 {\comment (endIndexValue)}
} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACX \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (startIndexKey)}
{\b {\b Forma_edge_property_t}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 {\comment (endIndexValue)}
} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACY \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (startIndexKey)}
{\b {\b Forma_vertex_property_t}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This struct contains the vertex property for Formaggia's example }{\comment (endIndexValue)}
)} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACZ \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (startIndexKey)}
{\b {\b BGLgeom::generic_edge_geometry< dim >}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 {\comment (endIndexValue)}
} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADA \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (startIndexKey)}
{\b {\b Geometry::Intersection}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A simple struct that contains the result of the intersection test }{\comment (endIndexValue)}
)} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADB \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (startIndexKey)}
{\b {\b intersector_base_class< Graph >}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 {\comment (endIndexValue)}
} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADC \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (startIndexKey)}
{\b {\b Geometry::Linear_edge}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A simple class that hanlde a linear edge  This class is thought to manage the description of the geometry of a linear edge, in order to compute intersections }{\comment (endIndexValue)}
)} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADD \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (startIndexKey)}
{\b {\b my_edge}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 {\comment (endIndexValue)}
} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADE \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (startIndexKey)}
{\b {\b new_reader_class< Source_data_structure, Target_data_structure, Edge_data_structure, Topological_data_structure >}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Abstract class that implements the functionality to read a file and get data from it  The users has to specify, in the derived class, all variables he need in order to store information read from the input file. Then, through the definition of Edge_data_structure and Vertex_data_structure, he can get separately all the information to put on edges and vertices }{\comment (endIndexValue)}
)} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADF \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (startIndexKey)}
{\b {\b no_topological_data}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An empty struct to handle the case the user do not need to store topological data  Inside this the user may put data as vertex and edge descriptor for the connettivity of the graph }{\comment (endIndexValue)}
)} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADG \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (startIndexKey)}
{\b {\b our_disjoint_sets< Graph >}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Template class to handle disjoint sets  The template parameters are:\par Label_map_t: the type of a std::map which key is a vertex descriptor and the value is an unsigned int which has the meaning of the current label of the component to which that vertex belongs to.\par Components_map_t: the type of a std::map which key is an unsigned int used as label for the group and the value is a std::set containing all the vertex descriptor of the vertices that have that label, i.e that belong to the same component }{\comment (endIndexValue)}
)} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADH \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (startIndexKey)}
{\b {\b BGLgeom::point< dim, Storage_t >}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class template for storing the vertex coordinates in n-dimentional space }{\comment (endIndexValue)}
)} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADI \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (startIndexKey)}
{\b {\b reader_base_class< Graph >}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 {\comment (endIndexValue)}
} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADJ \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (startIndexKey)}
{\b {\b vertex_data_structure< dim >}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 {\comment (endIndexValue)}
} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADK \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (startIndexKey)}
{\b {\b Zunino_edge_data}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 {\comment (endIndexValue)}
} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADL \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (startIndexKey)}
{\b {\b Zunino_edge_property_t}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 {\comment (endIndexValue)}
} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADM \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (startIndexKey)}
{\b {\b Zunino_reader< Zunino_source_data, Zunino_target_data, Zunino_edge_data, Zunino_topological_data >}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 {\comment (endIndexValue)}
} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADN \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (startIndexKey)}
{\b {\b Zunino_source_data}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 {\comment (endIndexValue)}
} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADO \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (startIndexKey)}
{\b {\b Zunino_target_data}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 {\comment (endIndexValue)}
} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADP \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (startIndexKey)}
{\b {\b Zunino_topological_data}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 {\comment (endIndexValue)}
} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADQ \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (endIndexList)}
\par}{\comment endFile}
{\comment end include annotated.rtf}

{\comment BeginRTFChapter}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Index\par \pard\plain 
{\tc \v File Index}
{\comment begin include files.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
File List{\comment endTitleHead}
\par \pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all documented files with brief descriptions:{\comment endTextBlock}
}
{\comment (startIndexList)}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\comment (startIndexKey)}
{\b include/{\b circular_edge_geometry.hpp}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 {\comment (endIndexValue)}
} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALX \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (startIndexKey)}
{\b include/{\b compute_euclidean_distance.hpp}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes the euclidean distance between two given vertices }{\comment (endIndexValue)}
)} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAB \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (startIndexKey)}
{\b include/{\b compute_euclidean_distance_imp.hpp}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 {\comment (endIndexValue)}
} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALY \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (startIndexKey)}
{\b include/{\b data_structure.hpp}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Declaration of generic data structure to represent vertex and edge properties }{\comment (endIndexValue)}
)} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAD \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (startIndexKey)}
{\b include/{\b dijkstra.hpp}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Solves the single-source shortest-paths problem on a weighted, directed graph with non-negative edge weights.  This function takes in input the graph, the source vertex and two vectors, one for the distance map and the other for the predecessor map, which will be filled with the results of the algorithm }{\comment (endIndexValue)}
)} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAI \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (startIndexKey)}
{\b include/{\b dijkstra_imp.hpp}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Solves the single-source shortest-paths problem on a weighted, directed graph with non-negative edge weights.  }{\comment (endIndexValue)}
)} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAK \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (startIndexKey)}
{\b include/{\b disjoint_components.hpp}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Identifies if there are fully disconnected subgraphs..  }{\comment (endIndexValue)}
)} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAM \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (startIndexKey)}
{\b include/{\b disjoint_components_imp.hpp}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Identifies if there are fully disconnected subgraphs }{\comment (endIndexValue)}
)} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAO \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (startIndexKey)}
{\b include/{\b edge_geometry.hpp}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Virtual base class for the geometry of an edge  }{\comment (endIndexValue)}
)} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAQ \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (startIndexKey)}
{\b include/{\b edge_property_max_flow.hpp}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 {\comment (endIndexValue)}
} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALZ \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (startIndexKey)}
{\b include/{\b Forma_edge_property.hpp}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This contains the struct for edge properties that has to be used for Formaggia's example  }{\comment (endIndexValue)}
)} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAR \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (startIndexKey)}
{\b include/{\b Forma_vertex_property.hpp}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This contains the struct for vertex properties that has to be used for Formaggia's example  }{\comment (endIndexValue)}
)} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAS \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (startIndexKey)}
{\b include/{\b generic_edge_geometry.hpp}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class for circular geometry of an edge  }{\comment (endIndexValue)}
)} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAT \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (startIndexKey)}
{\b include/{\b generic_point.hpp}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Templete class to handle points in 2D or 3D (or even greater) }{\comment (endIndexValue)}
)} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAU \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (startIndexKey)}
{\b include/{\b graph_builder.hpp}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Utilities to build a graph }{\comment (endIndexValue)}
)} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAV \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (startIndexKey)}
{\b include/{\b intersector_base_class.hpp}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Abstract class to handle intersections of edges in a graph with geometrical properties  It contains also some utilities needed to compute the intersection between two (linear) edges }{\comment (endIndexValue)}
)} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABA \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (startIndexKey)}
{\b include/{\b io_graph.hpp}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Declaration of functions related to input and output of the graph }{\comment (endIndexValue)}
)} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABD \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (startIndexKey)}
{\b include/{\b io_graph_imp.hpp}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Definition of functions related to input and output of the graph }{\comment (endIndexValue)}
)} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABM \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (startIndexKey)}
{\b include/{\b maximum_flow.hpp}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Header file for managing maximum_flow algorithm from BGL }{\comment (endIndexValue)}
)} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABT \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (startIndexKey)}
{\b include/{\b maximum_flow_imp.hpp}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implementations of the functions defined in {\b maximum_flow.hpp} }{\comment (endIndexValue)}
)} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABX \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (startIndexKey)}
{\b include/{\b new_reader_class.hpp}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Base abstract class to read input file }{\comment (endIndexValue)}
)} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACB \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (startIndexKey)}
{\b include/{\b new_reader_Zunino.hpp}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class for reading from Zunino files }{\comment (endIndexValue)}
)} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACC \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (startIndexKey)}
{\b include/{\b our_disjoint_sets.hpp}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class to handle disjoint sets  }{\comment (endIndexValue)}
)} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACD \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (startIndexKey)}
{\b include/{\b reader_base_class.hpp}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Base abstract class to read input file and creating the graph }{\comment (endIndexValue)}
)} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACE \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (startIndexKey)}
{\b include/{\b reader_Formaggia_class.hpp}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implementation of the {\b reader_base_class} for the Formaggia file format }{\comment (endIndexValue)}
)} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACF \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (startIndexKey)}
{\b include/{\b reader_Zunino_class.hpp}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implementation of the reader for Zunino file format }{\comment (endIndexValue)}
)} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACG \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (startIndexKey)}
{\b include/{\b topological_distance.hpp}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes topological distance.  }{\comment (endIndexValue)}
)} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACH \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (startIndexKey)}
{\b include/{\b topological_distance_imp.hpp}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes topological distance.  }{\comment (endIndexValue)}
)} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACJ \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (startIndexKey)}
{\b include/{\b Zunino_edge_property.hpp}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the struct for edge properties in Zunino's problem }{\comment (endIndexValue)}
)} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACL \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (startIndexKey)}
{\b src/{\b main_Formaggia.cpp}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Source code for Formaggia's example  }{\comment (endIndexValue)}
)} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACM \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (startIndexKey)}
{\b src/{\b main_Zunino.cpp}{\comment (endIndexKey)}
{\comment (startIndexValue)}
 ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Source code for Zunino example.  }{\comment (endIndexValue)}
)} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACO \\*MERGEFORMAT}{\fldrslt pagenum}}
{\comment (newParagraph)}
\par
{\comment (endIndexList)}
\par}{\comment endFile}
{\comment end include files.rtf}

{\comment BeginRTFChapter}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Documentation{\tc \v Class Documentation}
\par \pard\plain 
{\comment begin include classcircular__edge__geometry.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
circular_edge_geometry Class Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v circular_edge_geometry}
{\xe \v circular_edge_geometry}
{\comment writeAnchor (classcircular__edge__geometry)}
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b circular_edge_geometry} (point center_, double start_angle_, double end_angle_){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

point {\b value} (double parameter){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\comment (startItemList level=0) }
{{\comment (startItemListItem)}
{\comment (newParagraph)}
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
include/circular_edge_geometry.hpp{\comment (endItemListItem)}
{\comment (newParagraph)}
\par
{\comment (endItemList level=1)}
}{\comment endFile}
{\comment end include classcircular__edge__geometry.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include structdata__structure.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
data_structure< Edge_data_structure, Vertex_data_structure > Class Template Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v data_structure}
{\xe \v data_structure}
{\comment writeAnchor (structdata__structure)}
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An abstract class to handle the user definition data structure  The users has to specify, in the derived class, all variables he need in order to store information read from the input file. Then, through the definition of Edge_data_structure and Vertex_data_structure, he can get separately all the information to put on edges and vertices. }{\comment endParagraph}
}\par
{\comment startParagraph}
{
{\f2 #include <data_structure.hpp>}{\comment endParagraph}
}\par
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual Edge_data_structure {\b get_edge_data} ()=0{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A method to get the right data to append to an edge. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual Vertex_data_structure {\b get_vertex_data} ()=0{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A method to get the right data to append to a vertex. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual void {\b get_data_from_line} (std::ifstream &, {\b data_structure} &)=0{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The way the data from the input file are read  User has to specify how to read data from input file. }{\comment (endMemberDescription)}
}}
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\comment Begin SubSubSection}
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename Edge_data_structure, typename Vertex_data_structure> class data_structure< Edge_data_structure, Vertex_data_structure >{\comment (newParagraph)}
\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An abstract class to handle the user definition data structure  The users has to specify, in the derived class, all variables he need in order to store information read from the input file. Then, through the definition of Edge_data_structure and Vertex_data_structure, he can get separately all the information to put on edges and vertices. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid {\i Edge_data_structure} A struct where the user has to define type and name of the variables he needs to append to vertices as vertex bundled property \par
{\i Vertex_data_structure} A struct where the user has to define type and name of the variables he needs to append to edge as edge bundled property \par
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Precondition:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid It may be useful to declare a friend operator>> to help the reader read the data \par
}}{\comment endTextBlock}
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\comment (startItemList level=0) }
{{\comment (startItemListItem)}
{\comment (newParagraph)}
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
include/{\b data_structure.hpp}{\comment (endItemListItem)}
{\comment (newParagraph)}
\par
{\comment (endItemList level=1)}
}{\comment endFile}
{\comment end include structdata__structure.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include structedge__data__structure.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
edge_data_structure< dim > Struct Template Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v edge_data_structure}
{\xe \v edge_data_structure}
{\comment writeAnchor (structedge__data__structure)}
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

unsigned int {\b edge_id} = 0{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

std::string {\b label} = ""{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

double {\b lenght} = 0{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

double {\b capacity} = 0{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

double {\b diameter} = 0{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

double {\b weight} = 0{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

generic_edge_geometry< dim > {\b edge_geo}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}

{\comment Begin SubSubSection}
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<unsigned int dim> struct edge_data_structure< dim >{\comment (newParagraph)}
\par
}

{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\comment (startItemList level=0) }
{{\comment (startItemListItem)}
{\comment (newParagraph)}
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
include/{\b data_structure.hpp}{\comment (endItemListItem)}
{\comment (newParagraph)}
\par
{\comment (endItemList level=1)}
}{\comment endFile}
{\comment end include structedge__data__structure.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include classBGLgeom_1_1edge__geometry.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
BGLgeom::edge_geometry< dim > Class Template Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v BGLgeom::edge_geometry}
{\xe \v BGLgeom::edge_geometry}
{\comment writeAnchor (classBGLgeom_1_1edge__geometry)}
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
{\comment startClassDiagram }
Inheritance diagram for BGLgeom::edge_geometry< dim >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classBGLgeom_1_1edge__geometry.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual {\b BGLgeom::point}< dim > {\b value} (const double parameter)=0{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAJP}
{\bkmkend AAAAAAAAJP}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual std::vector< double > {\b first_derivatives} (const double x)=0{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAJQ}
{\bkmkend AAAAAAAAJQ}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual std::vector< double > {\b second_derivatives} (const double x)=0{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAJR}
{\bkmkend AAAAAAAAJR}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}

{\comment Begin SubSubSection}
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<unsigned int dim> class BGLgeom::edge_geometry< dim >{\comment (newParagraph)}
\par
}

{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\comment (startItemList level=0) }
{{\comment (startItemListItem)}
{\comment (newParagraph)}
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
include/{\b edge_geometry.hpp}{\comment (endItemListItem)}
{\comment (newParagraph)}
\par
{\comment (endItemList level=1)}
}{\comment endFile}
{\comment end include classBGLgeom_1_1edge__geometry.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include classedge__parametrization.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
edge_parametrization Class Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v edge_parametrization}
{\xe \v edge_parametrization}
{\comment writeAnchor (classedge__parametrization)}
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class holds the parametrization of the edge. }{\comment endParagraph}
}\par
{\comment startParagraph}
{
{\f2 #include <Forma_edge_property.hpp>}{\comment endParagraph}
}\par
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class holds the parametrization of the edge. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\comment endTextBlock}
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\comment (startItemList level=0) }
{{\comment (startItemListItem)}
{\comment (newParagraph)}
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
include/{\b Forma_edge_property.hpp}{\comment (endItemListItem)}
{\comment (newParagraph)}
\par
{\comment (endItemList level=1)}
}{\comment endFile}
{\comment end include classedge__parametrization.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include structedge__prop__max__flow__t.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
edge_prop_max_flow_t Struct Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v edge_prop_max_flow_t}
{\xe \v edge_prop_max_flow_t}
{\comment writeAnchor (structedge__prop__max__flow__t)}
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

double {\b capacity}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

double {\b residual_capacity}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

bool {\b original_edge}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\comment (startItemList level=0) }
{{\comment (startItemListItem)}
{\comment (newParagraph)}
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
include/edge_property_max_flow.hpp{\comment (endItemListItem)}
{\comment (newParagraph)}
\par
{\comment (endItemList level=1)}
}{\comment endFile}
{\comment end include structedge__prop__max__flow__t.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include classfinal.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
final< Graph > Class Template Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v final}
{\xe \v final}
{\comment writeAnchor (classfinal)}
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
{\comment startClassDiagram }
Inheritance diagram for final< Graph >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classfinal.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

typedef {\b reader_base_class}< Graph >::Vertex_desc {\b Vertex_desc}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

typedef {\b reader_base_class}< Graph >::Edge_desc {\b Edge_desc}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

typedef {\b intersector_base_class}< Graph >::Edge_iter {\b Edge_iter}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

typedef {\b intersector_base_class}< Graph >::Intersections_type {\b Intersections_type}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

typedef {\b reader_base_class}< Graph >::Vertex_desc {\b Vertex_desc}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

typedef {\b reader_base_class}< Graph >::Edge_desc {\b Edge_desc}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b reader_Formaggia} (Graph &_G){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default constructor (we need however to initialize the reference to the graph). }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b reader_Formaggia} (Graph &_G, std::string _file_name, unsigned int _num_dummy_lines){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b reader_Formaggia} (reader_Formaggia const &){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default copy constructor. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

reader_Formaggia & {\b operator=} (reader_Formaggia const &){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default assignment operator. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual {\b ~reader_Formaggia} (){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

void {\b set_e_to_be_removed} (Edge_desc const &_e_to_be_removed){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It allows to set e_to_be_removed. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

void {\b set_split_edge} (Edge_desc const &_split_edge){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It allows to set split_edge. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

void {\b set_intersection_new} (Vertex_desc const &_intersection_new){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It allows to set intersection_new. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

void {\b set_intersection_old} (Vertex_desc const &_intersection_old){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It allows to set intersection_old. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual void {\b read_data_from_line} (std::istringstream &temp){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is the way to interpret the data form Formaggia data file. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual void {\b give_new_source_properties} (){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It assigns properties to new_source in the right way. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual void {\b give_new_target_properties} (){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAEV}
{\bkmkend AAAAAAAAEV}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It assigns properties to new_target in the right way. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual void {\b give_new_edge_properties} (){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overriding of the abstract method. It assigns properties to new_edge in the right way. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual void {\b build_graph} (){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The set of instruction for one single step in the building of the graph. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

void {\b give_new_intersection_properties} (){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAEY}
{\bkmkend AAAAAAAAEY}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overriding of the abstrac method. It assigns properties to a new intersection point in the right way. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

void {\b give_split_edge_properties} (){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAEZ}
{\bkmkend AAAAAAAAEZ}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It assigns properties to split_edge in the right way. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual bool {\b are_intersected} (){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAFA}
{\bkmkend AAAAAAAAFA}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It checks if edges are intersected (only vertical or horizontal). }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual void {\b refine_graph} (){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAFB}
{\bkmkend AAAAAAAAFB}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Boh. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual void {\b order_intersections} (){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAFC}
{\bkmkend AAAAAAAAFC}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Bohboh. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b reader_Zunino} (Graph &_G){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAFD}
{\bkmkend AAAAAAAAFD}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default constructor (we need however to initialize the reference to the graph). }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b reader_Zunino} (Graph &_G, std::string _file_name, unsigned int _num_dummy_lines){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAFE}
{\bkmkend AAAAAAAAFE}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor: it assigns value only to the variables in {\b reader_base_class}, the others in reader_Zunino are defaulted. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b reader_Zunino} (reader_Zunino const &){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAFF}
{\bkmkend AAAAAAAAFF}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default copy constructor. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

reader_Zunino & {\b operator=} (reader_Zunino const &){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAFG}
{\bkmkend AAAAAAAAFG}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Assignment operator. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual {\b ~reader_Zunino} (){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual void {\b read_data_from_line} (std::istringstream &temp){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is the way we read and interpret a file from a Zunino input file format. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual void {\b build_graph} (){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It build 8the graph one edge at a time. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual void {\b give_new_source_properties} (){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It assign the right properties to new_source just added. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual void {\b give_new_target_properties} (){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAEV}
{\bkmkend AAAAAAAAEV}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It assign the right properties to new_target just added. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual void {\b give_new_edge_properties} (){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It assign the properties to the edge just added. }{\comment (endMemberDescription)}
}}
{\comment (endMemberList) }
}

{\comment Begin SubSubSection}
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename Graph> class final< Graph >{\comment (newParagraph)}
\par
}

{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\comment (startItemList level=0) }
{{\comment (startItemListItem)}
{\comment (newParagraph)}
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
include/{\b reader_Formaggia_class.hpp}{\comment (endItemListItem)}
{\comment (startItemListItem)}
{\comment (newParagraph)}
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
include/{\b reader_Zunino_class.hpp}{\comment (endItemListItem)}
{\comment (newParagraph)}
\par
{\comment (endItemList level=1)}
}{\comment endFile}
{\comment end include classfinal.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include structForma__edge__property__t.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Forma_edge_property_t Struct Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v Forma_edge_property_t}
{\xe \v Forma_edge_property_t}
{\comment writeAnchor (structForma__edge__property__t)}
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

unsigned int {\b frac_num}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAFI}
{\bkmkend AAAAAAAAFI}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This track which fracture this edge belongs to. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b edge_parametrization} {\b param}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAFJ}
{\bkmkend AAAAAAAAFJ}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It describes the parametrization of the real structure of the edge. }{\comment (endMemberDescription)}
}}
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\comment (startItemList level=0) }
{{\comment (startItemListItem)}
{\comment (newParagraph)}
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
include/{\b Forma_edge_property.hpp}{\comment (endItemListItem)}
{\comment (newParagraph)}
\par
{\comment (endItemList level=1)}
}{\comment endFile}
{\comment end include structForma__edge__property__t.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include structForma__vertex__property__t.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Forma_vertex_property_t Struct Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v Forma_vertex_property_t}
{\xe \v Forma_vertex_property_t}
{\comment writeAnchor (structForma__vertex__property__t)}
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This struct contains the vertex property for Formaggia's example. }{\comment endParagraph}
}\par
{\comment startParagraph}
{
{\f2 #include <Forma_vertex_property.hpp>}{\comment endParagraph}
}\par
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

point< 2 > {\b coord}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAFK}
{\bkmkend AAAAAAAAFK}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It contains the vertex coordinates. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

bool {\b is_external}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAFL}
{\bkmkend AAAAAAAAFL}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It tracks if this is an external point (that is: it was in the input file, or it has degree = 1). }{\comment (endMemberDescription)}
}}
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This struct contains the vertex property for Formaggia's example. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\comment endTextBlock}
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\comment (startItemList level=0) }
{{\comment (startItemListItem)}
{\comment (newParagraph)}
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
include/{\b Forma_vertex_property.hpp}{\comment (endItemListItem)}
{\comment (newParagraph)}
\par
{\comment (endItemList level=1)}
}{\comment endFile}
{\comment end include structForma__vertex__property__t.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include classBGLgeom_1_1generic__edge__geometry.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
BGLgeom::generic_edge_geometry< dim > Class Template Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v BGLgeom::generic_edge_geometry}
{\xe \v BGLgeom::generic_edge_geometry}
{\comment writeAnchor (classBGLgeom_1_1generic__edge__geometry)}
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
{\comment startClassDiagram }
Inheritance diagram for BGLgeom::generic_edge_geometry< dim >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classBGLgeom_1_1generic__edge__geometry.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b generic_edge_geometry} (std::function< {\b BGLgeom::point}< dim >(double)> value_){\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
s:[0,1] -> value_fun(s):[0,1]^dim }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b generic_edge_geometry} (){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAJS}
{\bkmkend AAAAAAAAJS}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
default constructor: linear edge (oppure defaultizzo gi\'E0\'20il fatto di chiamare sempre il linear_edge se non altrimenti specificato?) }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual std::vector< double > {\b first_derivatives} (const double x){\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
first derivative }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual std::vector< double > {\b second_derivatives} (const double x){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAJT}
{\bkmkend AAAAAAAAJT}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
second derivative }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b BGLgeom::point}< dim > {\b value} (const double parameter){\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
curvilinear abscissa }{\comment (endMemberDescription)}
}}
{\comment (endMemberList) }
}

{\comment Begin SubSubSection}
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<unsigned int dim> class BGLgeom::generic_edge_geometry< dim >{\comment (newParagraph)}
\par
}

{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation{\comment endGroupHeader}
\par
\pard\plain 
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v generic_edge_geometry\:BGLgeom::generic_edge_geometry}
{\xe \v BGLgeom::generic_edge_geometry\:generic_edge_geometry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<unsigned int dim> {\b BGLgeom::generic_edge_geometry}< dim >::{\b generic_edge_geometry} ({\comment (startParameterList)}
std::function< {\b BGLgeom::point}< dim >(double)> {\i value_}){\f2  [inline]}{\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAJU}
{\bkmkend AAAAAAAAJU}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
s:[0,1] -> value_fun(s):[0,1]^dim }{\comment endParagraph}
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
stores the function which takes in input the "normalized" parametrization of the edge constructor \par
}}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation{\comment endGroupHeader}
\par
\pard\plain 
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v first_derivatives\:BGLgeom::generic_edge_geometry}
{\xe \v BGLgeom::generic_edge_geometry\:first_derivatives}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<unsigned int dim> virtual std::vector<double> {\b BGLgeom::generic_edge_geometry}< dim >::first_derivatives ({\comment (startParameterList)}
const double {\i x}){\f2  [inline, virtual]}{\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAJV}
{\bkmkend AAAAAAAAJV}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
first derivative }{\comment endParagraph}
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\comment startParagraph}
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
declare the {\b point} that will contain the result \par
}{\comment endParagraph}
}\par
{\comment startParagraph}
{
Implements {\b BGLgeom::edge_geometry< dim >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAACU \\*MERGEFORMAT}{\fldrslt pagenum}}}).{\comment endParagraph}
}\par
}
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v value\:BGLgeom::generic_edge_geometry}
{\xe \v BGLgeom::generic_edge_geometry\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<unsigned int dim> virtual {\b BGLgeom::point}<dim> {\b BGLgeom::generic_edge_geometry}< dim >::value ({\comment (startParameterList)}
const double {\i parameter}){\f2  [inline, virtual]}{\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAJW}
{\bkmkend AAAAAAAAJW}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
curvilinear abscissa }{\comment endParagraph}
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
returns value fun (parametrized between 0 and 1) in s between 0 and 1 \par
}{\comment startParagraph}
{
Implements {\b BGLgeom::edge_geometry< dim >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAACU \\*MERGEFORMAT}{\fldrslt pagenum}}}).{\comment endParagraph}
}\par
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\comment (startItemList level=0) }
{{\comment (startItemListItem)}
{\comment (newParagraph)}
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
include/{\b generic_edge_geometry.hpp}{\comment (endItemListItem)}
{\comment (newParagraph)}
\par
{\comment (endItemList level=1)}
}{\comment endFile}
{\comment end include classBGLgeom_1_1generic__edge__geometry.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include structGeometry_1_1Intersection.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Geometry::Intersection Struct Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v Geometry::Intersection}
{\xe \v Geometry::Intersection}
{\comment writeAnchor (structGeometry_1_1Intersection)}
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A simple struct that contains the result of the intersection test. }{\comment endParagraph}
}\par
{\comment startParagraph}
{
{\f2 #include <intersector_base_class.hpp>}{\comment endParagraph}
}\par
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b intersect} = false{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Segments intersects. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

unsigned int {\b numberOfIntersections} = 0u{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAALN}
{\bkmkend AAAAAAAALN}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of intersections (max 2). }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

std::array< point< 2 >, 2 > {\b intersectionPoint} = std::array<point<2>,2>\{point<2>(), point<2>()\}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAALO}
{\bkmkend AAAAAAAALO}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Intersection} points coordinates. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::array< std::array< bool, 2 >, 2 > {\b endPointIsIntersection}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::array< std::array< int, 2 >, 2 > {\b otherEdgePoint}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

bool {\b parallel} = false{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAALP}
{\bkmkend AAAAAAAALP}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Edges are parallel. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

bool {\b identical} = false{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAALQ}
{\bkmkend AAAAAAAALQ}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Edges are identical. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

bool {\b collinear} = false{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAALR}
{\bkmkend AAAAAAAALR}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Edges are collinear (and thus also parallel). }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

bool {\b good} = true{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAALS}
{\bkmkend AAAAAAAALS}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Something is not ok. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

double {\b distance} = 0.0{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAALT}
{\bkmkend AAAAAAAALT}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Distance, makes sense only if parallel=true. }{\comment (endMemberDescription)}
}}
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A simple struct that contains the result of the intersection test. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To be able to treat the most general case each segment is allowed to have up to two intersections. It happens if the segments overlaps\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Todo:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid It can be bettered by adding another attribute that indicates, in the case of two edges end which coincides the relative position on the edge. It requires a simple modification of the function segmentIntersect \par
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Piece of code provided by prof. Formaggia \par
}}{\comment endTextBlock}
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation{\comment endGroupHeader}
\par
\pard\plain 
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v endPointIsIntersection\:Geometry::Intersection}
{\xe \v Geometry::Intersection\:endPointIsIntersection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::array<std::array<bool,2>, 2> {\b Geometry::Intersection::endPointIsIntersection}{\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAALU}
{\bkmkend AAAAAAAALU}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{\comment (startCodeFragment) }
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\comment (lineBreak)}
\par
            std::array<std::array<bool,2>, 2>\{std::array<bool,2>\{false,false\}, std::array<bool,2>\{false,false\} \}{\comment (lineBreak)}
\par
{\comment (endCodeFragment) }
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Intersection} may be end point\par
endPointIsIntersection[i][j]=true then end j of edge i is at the intersection \par
}}
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v intersect\:Geometry::Intersection}
{\xe \v Geometry::Intersection\:intersect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool {\b Geometry::Intersection::intersect} = false{\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAALV}
{\bkmkend AAAAAAAALV}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Segments intersects. }{\comment endParagraph}
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
True is there is any intersection \par
}}
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v otherEdgePoint\:Geometry::Intersection}
{\xe \v Geometry::Intersection\:otherEdgePoint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::array<std::array<int,2>, 2> {\b Geometry::Intersection::otherEdgePoint}{\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAALW}
{\bkmkend AAAAAAAALW}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{\comment (startCodeFragment) }
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\comment (lineBreak)}
\par
            std::array<std::array<int,2>, 2>\{std::array<int,2>\{-1,-1\}, std::array<int,2>\{-1,-1\}\}{\comment (lineBreak)}
\par
{\comment (endCodeFragment) }
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
EdgeS join at the end. In that case endPointIsIntersection will be true and the corresponding entry will indicate the numering of the end of the other edge. -1 indicates that the end is not joined. So if endPointIsIntersection[i][j]=true we have otherEdgePoint[i][j]=-1 //End point is not joined with the other edge otherEdgePoint[i][j]= k //End point j of edge j is joined with end point k of other edge \par
}}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\comment (startItemList level=0) }
{{\comment (startItemListItem)}
{\comment (newParagraph)}
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
include/{\b intersector_base_class.hpp}{\comment (endItemListItem)}
{\comment (newParagraph)}
\par
{\comment (endItemList level=1)}
}{\comment endFile}
{\comment end include structGeometry_1_1Intersection.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include classintersector__base__class.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
intersector_base_class< Graph > Class Template Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v intersector_base_class}
{\xe \v intersector_base_class}
{\comment writeAnchor (classintersector__base__class)}
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
{\comment startClassDiagram }
Inheritance diagram for intersector_base_class< Graph >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classintersector__base__class.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

typedef boost::graph_traits< Graph >::edge_descriptor {\b Edge_desc}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAFM}
{\bkmkend AAAAAAAAFM}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

typedef boost::graph_traits< Graph >::edge_iterator {\b Edge_iter}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAFN}
{\bkmkend AAAAAAAAFN}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

typedef boost::graph_traits< Graph >::vertex_descriptor {\b Vertex_desc}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAFO}
{\bkmkend AAAAAAAAFO}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

typedef std::pair< point< 2 >, point< 2 > > {\b Line}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAFP}
{\bkmkend AAAAAAAAFP}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

typedef std::vector< std::pair< point< 2 >, Edge_desc > > {\b Intersections_type}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAFQ}
{\bkmkend AAAAAAAAFQ}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

typedef std::pair< point< 2 >, Edge_desc > {\b Intersections_value_type}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAFR}
{\bkmkend AAAAAAAAFR}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b intersector_base_class} (){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAFS}
{\bkmkend AAAAAAAAFS}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default constructor (initialization of the reference to the graph needed). }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b intersector_base_class} ({\b intersector_base_class} const &){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAFT}
{\bkmkend AAAAAAAAFT}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copy constructor. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual {\b ~intersector_base_class} (){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAFU}
{\bkmkend AAAAAAAAFU}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b intersector_base_class} & {\b operator=} ({\b intersector_base_class} const &){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAFV}
{\bkmkend AAAAAAAAFV}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Assignment operator. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual void {\b set_Edge1} (point< 2 > const &P1, point< 2 > const &P2){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAFW}
{\bkmkend AAAAAAAAFW}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It sets Edge1 from two points. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual void {\b set_Edge1} (Line _L){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAFX}
{\bkmkend AAAAAAAAFX}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It sets Edge1 from another Line. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual void {\b set_Edge2} (point< 2 > const &P1, point< 2 > const &P2){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAFY}
{\bkmkend AAAAAAAAFY}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It sets Edge2 from two points. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual void {\b set_Edge2} (Line _L){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAFZ}
{\bkmkend AAAAAAAAFZ}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It sets Edge1 from another Line. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual void {\b set_Edge2_descriptor} (Edge_desc _Edge2_desc){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAGA}
{\bkmkend AAAAAAAAGA}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It allows to set Edge2_descriptor. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual bool {\b are_intersected} ()=0{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAGB}
{\bkmkend AAAAAAAAGB}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It checks if Edge1 and Edge2 are actually intersected  If the two edge are intersecating, this method must store in the class variable intersection_point the coordinates of the intersection found. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual void {\b store_intersection} (){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAGC}
{\bkmkend AAAAAAAAGC}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It pushes back a new intersection point between Edge1 and Edge2, remembering the edge descriptor of Edge2. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual void {\b clear_intersections} (){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAGD}
{\bkmkend AAAAAAAAGD}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual void {\b refine_graph} ()=0{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAGE}
{\bkmkend AAAAAAAAGE}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It explains how to rebuilt graph after the intersections were computed  It has to inteface with private attributes of the derived class in order to set edge and vertex properties in the right way. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual void {\b order_intersections} ()=0{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This reorders the vector intersections according to some order, defined by the user  It will consist of a call to "sort" algorithm, in which the compare function must be user defined, choosing a possible ordering in the 2D space. }{\comment (endMemberDescription)}
}}
{\comment (endMemberList) }
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

Line {\b Edge1}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAGG}
{\bkmkend AAAAAAAAGG}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The first of the two edge that are (maybe) intersecating  If the user has to perform multiple intersection between a fixed edge and all the other edges in the graph, Edge1 is thougth to be the fixed edge. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

Line {\b Edge2}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAGH}
{\bkmkend AAAAAAAAGH}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The second of the two edge that are (maybe) intersecating  If the user has to perform multiple intersection between a fixed edge and all the other edges in the graph, Edge2 is thougth to be the variable edge. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

Intersections_type {\b intersections}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAGI}
{\bkmkend AAAAAAAAGI}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Vector that will contains the intersection point and the edge descriptor of the edge with which the current edge is intersecating. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

point< 2 > {\b intersection_point}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAGJ}
{\bkmkend AAAAAAAAGJ}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The intersection point between Edge1 and Edge2 (if present). }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

Edge_desc {\b Edge2_descriptor}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAGK}
{\bkmkend AAAAAAAAGK}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Edge descriptor of Edge2.  If the user has to perform multiple intersections between Edge1 (fixed) and Edge2 (variable), this tracks the edge descriptor of the edges in the graph that are intersecating Edge1 (one at a time). }{\comment (endMemberDescription)}
}}
{\comment (endMemberList) }
}

{\comment Begin SubSubSection}
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename Graph> class intersector_base_class< Graph >{\comment (newParagraph)}
\par
}

{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\comment (startItemList level=0) }
{{\comment (startItemListItem)}
{\comment (newParagraph)}
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
include/{\b intersector_base_class.hpp}{\comment (endItemListItem)}
{\comment (newParagraph)}
\par
{\comment (endItemList level=1)}
}{\comment endFile}
{\comment end include classintersector__base__class.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include classGeometry_1_1Linear__edge.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Geometry::Linear_edge Class Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v Geometry::Linear_edge}
{\xe \v Geometry::Linear_edge}
{\comment writeAnchor (classGeometry_1_1Linear__edge)}
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A simple class that hanlde a linear edge  This class is thought to manage the description of the geometry of a linear edge, in order to compute intersections. }{\comment endParagraph}
}\par
{\comment startParagraph}
{
{\f2 #include <intersector_base_class.hpp>}{\comment endParagraph}
}\par
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b Linear_edge} (){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAALE}
{\bkmkend AAAAAAAALE}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default constructor. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b extremes_are_set} (false){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAALF}
{\bkmkend AAAAAAAALF}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b Linear_edge} (point< 2 > const &SRC, point< 2 > const &TGT){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAALG}
{\bkmkend AAAAAAAALG}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b extremes_are_set} (true){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAALH}
{\bkmkend AAAAAAAALH}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b Linear_edge} ({\b Linear_edge} const &){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAALI}
{\bkmkend AAAAAAAALI}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copy constructor. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b Linear_edge} & {\b operator=} ({\b Linear_edge} const &){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAALJ}
{\bkmkend AAAAAAAALJ}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Assignment operator. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

void {\b set} (point< 2 > const &SRC, point< 2 > const &TGT){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAALK}
{\bkmkend AAAAAAAALK}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setting the two end points (extremes) of the edge. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

point< 2 > {\b operator[]} (std::size_t i){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAALL}
{\bkmkend AAAAAAAALL}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading of operator[] to access each of the two end points. Usefull in algorithms  extremes[0] = source, extremes[1] = target of the edge. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

point< 2 > {\b operator[]} (std::size_t i) const {\comment endDoxyAnchor}
{\bkmkstart AAAAAAAALM}
{\bkmkend AAAAAAAALM}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A simple class that hanlde a linear edge  This class is thought to manage the description of the geometry of a linear edge, in order to compute intersections. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Remarks:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid The class must have an overload of operator[] in order to run in the function that computes intersections \par
}}{\comment endTextBlock}
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\comment (startItemList level=0) }
{{\comment (startItemListItem)}
{\comment (newParagraph)}
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
include/{\b intersector_base_class.hpp}{\comment (endItemListItem)}
{\comment (newParagraph)}
\par
{\comment (endItemList level=1)}
}{\comment endFile}
{\comment end include classGeometry_1_1Linear__edge.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include structmy__edge.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
my_edge Struct Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v my_edge}
{\xe \v my_edge}
{\comment writeAnchor (structmy__edge)}
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\comment (startItemList level=0) }
{{\comment (startItemListItem)}
{\comment (newParagraph)}
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
include/{\b data_structure.hpp}{\comment (endItemListItem)}
{\comment (newParagraph)}
\par
{\comment (endItemList level=1)}
}{\comment endFile}
{\comment end include structmy__edge.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include classnew__reader__class.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
new_reader_class< Source_data_structure, Target_data_structure, Edge_data_structure, Topological_data_structure > Class Template Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v new_reader_class}
{\xe \v new_reader_class}
{\comment writeAnchor (classnew__reader__class)}
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Abstract class that implements the functionality to read a file and get data from it  The users has to specify, in the derived class, all variables he need in order to store information read from the input file. Then, through the definition of Edge_data_structure and Vertex_data_structure, he can get separately all the information to put on edges and vertices. }{\comment endParagraph}
}\par
{\comment startParagraph}
{
{\f2 #include <new_reader_class.hpp>}{\comment endParagraph}
}\par
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b new_reader_class} (){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAGL}
{\bkmkend AAAAAAAAGL}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default constructor. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b new_reader_class} (std::string _filename){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAGM}
{\bkmkend AAAAAAAAGM}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b new_reader_class} ({\b new_reader_class} const &){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAGN}
{\bkmkend AAAAAAAAGN}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copy constructor. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b new_reader_class} &{\b new_reader_class} const &virtual void {\b set_input} (std::string _filename){\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Assignment operator. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b ignore_dummy_lines} (unsigned int const &n){\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Ignore n lines of the input code that the user knows he has not to read. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual void {\b read_line} (){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAGO}
{\bkmkend AAAAAAAAGO}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads one line and put it into a istringstream. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual bool {\b is_eof} (){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAGP}
{\bkmkend AAAAAAAAGP}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To know outside the class if we have reached the end of file. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual void {\b get_data_from_line} ()=0{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAGQ}
{\bkmkend AAAAAAAAGQ}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads the data from one single line. It has to be specified by the user  It reads data form the istringstream iss_line that is defined as an attribute of the class and it is updated after every call of {\b read_line()}. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual Edge_data_structure {\b get_edge_data} ()=0{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAGR}
{\bkmkend AAAAAAAAGR}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A method to get the right data to append to an edge. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual Source_data_structure {\b get_source_data} ()=0{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAGS}
{\bkmkend AAAAAAAAGS}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A method to get the right data to append to the source. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual Target_data_structure {\b get_target_data} ()=0{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAGT}
{\bkmkend AAAAAAAAGT}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A method to get the right data to append to the target. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual Topological_data_structure {\b get_topological_data} ()=0{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAGU}
{\bkmkend AAAAAAAAGU}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A method to get the right topological data from a line. }{\comment (endMemberDescription)}
}}
{\comment (endMemberList) }
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

std::string {\b filename}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAGV}
{\bkmkend AAAAAAAAGV}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The name of the file to be read. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

std::ifstream {\b in_file}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAGW}
{\bkmkend AAAAAAAAGW}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
File stream to handle the input file. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

std::string {\b line}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAGX}
{\bkmkend AAAAAAAAGX}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
String in which the data read from a line are put. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

std::istringstream {\b iss_line}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAGY}
{\bkmkend AAAAAAAAGY}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Data put in line are converted in istringstream to be got by the user. }{\comment (endMemberDescription)}
}}
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\comment Begin SubSubSection}
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename Source_data_structure, typename Target_data_structure, typename Edge_data_structure, typename Topological_data_structure = no_topological_data> class new_reader_class< Source_data_structure, Target_data_structure, Edge_data_structure, Topological_data_structure >{\comment (newParagraph)}
\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Abstract class that implements the functionality to read a file and get data from it  The users has to specify, in the derived class, all variables he need in order to store information read from the input file. Then, through the definition of Edge_data_structure and Vertex_data_structure, he can get separately all the information to put on edges and vertices. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid {\i Edge_data_structure} A struct where the user has to define type and name of the variables he needs to append to vertices as vertex bundled property \par
{\i Vertex_data_structure} A struct where the user has to define type and name of the variables he needs to append to edge as edge bundled property \par
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Precondition:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid It may be useful to declare a friend operator>> to help the reader read the data \par
}}{\comment endTextBlock}
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation{\comment endGroupHeader}
\par
\pard\plain 
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v ignore_dummy_lines\:new_reader_class}
{\xe \v new_reader_class\:ignore_dummy_lines}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Source_data_structure, typename Target_data_structure, typename Edge_data_structure, typename Topological_data_structure = no_topological_data> virtual void {\b new_reader_class}< Source_data_structure, Target_data_structure, Edge_data_structure, Topological_data_structure >::ignore_dummy_lines ({\comment (startParameterList)}
unsigned int const & {\i n}){\f2  [inline, virtual]}{\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAGZ}
{\bkmkend AAAAAAAAGZ}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Ignore n lines of the input code that the user knows he has not to read. }{\comment endParagraph}
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Remarks:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid It sets the file stream n lines after the previous position \par
}}}
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v set_input\:new_reader_class}
{\xe \v new_reader_class\:set_input}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Source_data_structure, typename Target_data_structure, typename Edge_data_structure, typename Topological_data_structure = no_topological_data> {\b new_reader_class}& {\b new_reader_class} const& virtual void {\b new_reader_class}< Source_data_structure, Target_data_structure, Edge_data_structure, Topological_data_structure >::set_input ({\comment (startParameterList)}
std::string {\i _filename}){\f2  [inline, virtual]}{\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAHA}
{\bkmkend AAAAAAAAHA}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Assignment operator. }{\comment endParagraph}
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the input file to read \par
}}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\comment (startItemList level=0) }
{{\comment (startItemListItem)}
{\comment (newParagraph)}
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
include/{\b new_reader_class.hpp}{\comment (endItemListItem)}
{\comment (newParagraph)}
\par
{\comment (endItemList level=1)}
}{\comment endFile}
{\comment end include classnew__reader__class.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include structno__topological__data.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
no_topological_data Struct Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v no_topological_data}
{\xe \v no_topological_data}
{\comment writeAnchor (structno__topological__data)}
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An empty struct to handle the case the user do not need to store topological data  Inside this the user may put data as vertex and edge descriptor for the connettivity of the graph. }{\comment endParagraph}
}\par
{\comment startParagraph}
{
{\f2 #include <new_reader_class.hpp>}{\comment endParagraph}
}\par
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An empty struct to handle the case the user do not need to store topological data  Inside this the user may put data as vertex and edge descriptor for the connettivity of the graph. \par
}{\comment endTextBlock}
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\comment (startItemList level=0) }
{{\comment (startItemListItem)}
{\comment (newParagraph)}
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
include/{\b new_reader_class.hpp}{\comment (endItemListItem)}
{\comment (newParagraph)}
\par
{\comment (endItemList level=1)}
}{\comment endFile}
{\comment end include structno__topological__data.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include classour__disjoint__sets.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
our_disjoint_sets< Graph > Class Template Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v our_disjoint_sets}
{\xe \v our_disjoint_sets}
{\comment writeAnchor (classour__disjoint__sets)}
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Template class to handle disjoint sets  The template parameters are:\par Label_map_t: the type of a std::map which key is a vertex descriptor and the value is an unsigned int which has the meaning of the current label of the component to which that vertex belongs to.\par Components_map_t: the type of a std::map which key is an unsigned int used as label for the group and the value is a std::set containing all the vertex descriptor of the vertices that have that label, i.e that belong to the same component. }{\comment endParagraph}
}\par
{\comment startParagraph}
{
{\f2 #include <our_disjoint_sets.hpp>}{\comment endParagraph}
}\par
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

typedef boost::graph_traits< Graph >::vertex_iterator {\b Vertex_iter}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAHB}
{\bkmkend AAAAAAAAHB}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

typedef boost::graph_traits< Graph >::vertex_descriptor {\b Vertex_desc}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAHC}
{\bkmkend AAAAAAAAHC}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

typedef std::map< Vertex_desc, unsigned int > {\b Label_map_t}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAHD}
{\bkmkend AAAAAAAAHD}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

typedef std::map< unsigned int, std::list< Vertex_desc > > {\b Components_map_t}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAHE}
{\bkmkend AAAAAAAAHE}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

typedef Label_map_t::key_type {\b Label_key_t}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAHF}
{\bkmkend AAAAAAAAHF}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

typedef Label_map_t::mapped_type {\b Label_mapped_t}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAHG}
{\bkmkend AAAAAAAAHG}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

typedef Components_map_t::key_type {\b Components_key_t}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAHH}
{\bkmkend AAAAAAAAHH}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

typedef Components_map_t::mapped_type {\b Components_mapped_t}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAHI}
{\bkmkend AAAAAAAAHI}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

typedef Components_mapped_t::value_type {\b Comp_mapped_vertex_t}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAHJ}
{\bkmkend AAAAAAAAHJ}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b our_disjoint_sets} (Graph &_G){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAHK}
{\bkmkend AAAAAAAAHK}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default constructor. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b our_disjoint_sets} ({\b our_disjoint_sets} const &){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAHL}
{\bkmkend AAAAAAAAHL}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copy constructor. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b our_disjoint_sets} & {\b operator=} ({\b our_disjoint_sets} const &){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAHM}
{\bkmkend AAAAAAAAHM}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Assignment operator. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b ~our_disjoint_sets} (){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAHN}
{\bkmkend AAAAAAAAHN}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

void {\b make_label_map} (){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAHO}
{\bkmkend AAAAAAAAHO}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It creates the label map starting form the Graph  The label_map is set up by associating to each vertex descriptor a progressive unsigned int as label, that indicates to which component the vertex belongs to. In other words, label_map is set up by assuming that each vertex is a separated component. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

Label_mapped_t {\b get_label} (Label_key_t const &vertex){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAHP}
{\bkmkend AAAAAAAAHP}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It returns, from the label_map, the label of the component which the vertex belongs to. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

void {\b set_label} (Label_key_t const &vertex, Label_mapped_t const &label){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAHQ}
{\bkmkend AAAAAAAAHQ}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It allows to set the label of that vertex in label map. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

bool {\b is_present_component} (Components_key_t const &label_of_the_component){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAHR}
{\bkmkend AAAAAAAAHR}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Checks if a particular component (i.e its label) is already present in the components_map. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

std::pair< typename Components_mapped_t::iterator, typename Components_mapped_t::iterator > {\b get_iterator} (Components_key_t const &label_of_the_component){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAHS}
{\bkmkend AAAAAAAAHS}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It returns a pair containing the iterator to begin and end of the list that contains all the verteices of the given component. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

void {\b new_component} (Components_key_t const &label_value){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAHT}
{\bkmkend AAAAAAAAHT}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It creates a new component with the given label value as key in components_map. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

void {\b insert_vertex_in_component} (Comp_mapped_vertex_t const &vertex, Components_key_t const &label_value){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAHU}
{\bkmkend AAAAAAAAHU}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It add the given vertex descriptor to the component with that label. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

void {\b insert_tgt_comp_in_src_comp} (Components_key_t const &tgt_label_value, Components_key_t const &src_label_value){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAHV}
{\bkmkend AAAAAAAAHV}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It insert the target component in the source component. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

void {\b erase_component} (Components_key_t const &label_value){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAHW}
{\bkmkend AAAAAAAAHW}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It removes from components_map the component with the given key (=label of the component). }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

Components_map_t {\b get_components_map} (){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAHX}
{\bkmkend AAAAAAAAHX}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It returns the components_map outside the class. }{\comment (endMemberDescription)}
}}
{\comment (endMemberList) }
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

std::ostream & {\b operator<<} (std::ostream &out, {\b our_disjoint_sets} &dsets){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAHY}
{\bkmkend AAAAAAAAHY}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading of operator<< to view components_map. }{\comment (endMemberDescription)}
}}
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\comment Begin SubSubSection}
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename Graph> class our_disjoint_sets< Graph >{\comment (newParagraph)}
\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Template class to handle disjoint sets  The template parameters are:\par Label_map_t: the type of a std::map which key is a vertex descriptor and the value is an unsigned int which has the meaning of the current label of the component to which that vertex belongs to.\par Components_map_t: the type of a std::map which key is an unsigned int used as label for the group and the value is a std::set containing all the vertex descriptor of the vertices that have that label, i.e that belong to the same component. \par
}{\comment endTextBlock}
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\comment (startItemList level=0) }
{{\comment (startItemListItem)}
{\comment (newParagraph)}
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
include/{\b our_disjoint_sets.hpp}{\comment (endItemListItem)}
{\comment (newParagraph)}
\par
{\comment (endItemList level=1)}
}{\comment endFile}
{\comment end include classour__disjoint__sets.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include classBGLgeom_1_1point.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
BGLgeom::point< dim, Storage_t > Class Template Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v BGLgeom::point}
{\xe \v BGLgeom::point}
{\comment writeAnchor (classBGLgeom_1_1point)}
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class template for storing the vertex coordinates in n-dimentional space. }{\comment endParagraph}
}\par
{\comment startParagraph}
{
{\f2 #include <generic_point.hpp>}{\comment endParagraph}
}\par
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b point} (){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAJX}
{\bkmkend AAAAAAAAJX}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default constructor. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b point} (std::initializer_list< Storage_t > args){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAJY}
{\bkmkend AAAAAAAAJY}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b point} (std::array< Storage_t, dim > const &P){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAJZ}
{\bkmkend AAAAAAAAJZ}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor from a std::array<Storage_t,dim>. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b point} ({\b point}< dim, Storage_t > const &){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAKA}
{\bkmkend AAAAAAAAKA}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copy constructor. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b point}< dim, Storage_t > & {\b operator=} ({\b point}< dim, Storage_t > const &){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAKB}
{\bkmkend AAAAAAAAKB}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Assignement operator. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b point}< dim, Storage_t > & {\b operator=} (std::array< Storage_t, dim > const &P){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAKC}
{\bkmkend AAAAAAAAKC}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overload of assignment operator to create conversion directly form std::array<Storage_t, dim>. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

Storage_t {\b x} (){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAKD}
{\bkmkend AAAAAAAAKD}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the first coordinate. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

Storage_t {\b x} () const {\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAKE}
{\bkmkend AAAAAAAAKE}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

Storage_t {\b y} (){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAKF}
{\bkmkend AAAAAAAAKF}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the second coordinate. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

Storage_t {\b y} () const {\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAKG}
{\bkmkend AAAAAAAAKG}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

Storage_t {\b z} (){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAKH}
{\bkmkend AAAAAAAAKH}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the third coordinate. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

Storage_t {\b z} () const {\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAKI}
{\bkmkend AAAAAAAAKI}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

std::size_t {\b get_dim} (){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAKJ}
{\bkmkend AAAAAAAAKJ}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the dimension of the {\b point}, and so the number of the coordinates. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

std::size_t {\b get_dim} () const {\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAKK}
{\bkmkend AAAAAAAAKK}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

void {\b set_x} (double const &x){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAKL}
{\bkmkend AAAAAAAAKL}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set coordinate x of the {\b point}, corresponding to coord[0]. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

void {\b set_y} (double const &y){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAKM}
{\bkmkend AAAAAAAAKM}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set coordinate y of the {\b point}, corresponding to coord[1]. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

void {\b set_z} (double const &z){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAKN}
{\bkmkend AAAAAAAAKN}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set coordinate z of the {\b point}, corresponding to coord[i]. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

void {\b set} (std::initializer_list< Storage_t > args){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAKO}
{\bkmkend AAAAAAAAKO}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set method to assign coordinates to an already existing {\b point}. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

Storage_t & {\b operator[]} (std::size_t i){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAKP}
{\bkmkend AAAAAAAAKP}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading of operator[], to get the i-th coordinate or write in it. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

Storage_t & {\b operator[]} (std::size_t i) const {\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAKQ}
{\bkmkend AAAAAAAAKQ}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

bool {\b operator<} ({\b point}< dim, Storage_t > const &P2) const {\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAKR}
{\bkmkend AAAAAAAAKR}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Operator< overloading  Point1 < Point2 if Point1.x is smaller than Point2.x; if they are equal, compare in the same waythe y coordinate, and so on. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

bool {\b operator>} ({\b point}< dim, Storage_t > const &point2) const {\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAKS}
{\bkmkend AAAAAAAAKS}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Operator> overloading  It is the negation of operator<. }{\comment (endMemberDescription)}
}}
{\comment (endMemberList) }
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

std::ostream & {\b operator<<} (std::ostream &out, {\b point}< dim, Storage_t > const &P){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAKT}
{\bkmkend AAAAAAAAKT}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overload of operator<<. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

std::istream & {\b operator>>} (std::istream &in, {\b point}< dim, Storage_t > &P){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAKU}
{\bkmkend AAAAAAAAKU}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
operator>> overloading }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b point}< dim, Storage_t > {\b operator-} ({\b point}< dim, Storage_t > const &P, {\b point}< dim, Storage_t > const &Q){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAKV}
{\bkmkend AAAAAAAAKV}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading of operator- for points. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b point}< dim, Storage_t > {\b operator-} ({\b point}< dim, Storage_t > const &P, std::array< Storage_t, dim > const &a){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAKW}
{\bkmkend AAAAAAAAKW}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overload of operator-  It defines difference between points and std::array, to define conversion between this two similar classes. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b point}< dim, Storage_t > {\b operator-} (std::array< Storage_t, dim > const &a, {\b point}< dim, Storage_t > const &P){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAKX}
{\bkmkend AAAAAAAAKX}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b point}< dim, Storage_t > {\b operator+} ({\b point}< dim, Storage_t > const &P, {\b point}< dim, Storage_t > const &Q){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAKY}
{\bkmkend AAAAAAAAKY}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading of operator+ for points. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b point}< dim, Storage_t > {\b operator+} ({\b point}< dim, Storage_t > const &P, std::array< Storage_t, dim > const &a){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAKZ}
{\bkmkend AAAAAAAAKZ}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overload of operator+  It defines sum between points and std::array, to define conversion between this two similar classes. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b point}< dim, Storage_t > {\b operator+} (std::array< Storage_t, dim > const &a, {\b point}< dim, Storage_t > const &P){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAALA}
{\bkmkend AAAAAAAALA}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b point}< dim, Storage_t > {\b operator*} (double const &k, {\b point}< dim, Storage_t > const &P){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAALB}
{\bkmkend AAAAAAAALB}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading of operator*  It represents the multiplication of the coordinates of a {\b point} for a scalar. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b point}< dim, Storage_t > {\b operator*} ({\b point}< dim, Storage_t > const &P, double const &k){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAALC}
{\bkmkend AAAAAAAALC}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b point}< dim, Storage_t > {\b operator/} ({\b point}< dim, Storage_t > const &P, double const &k){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAALD}
{\bkmkend AAAAAAAALD}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading of operator/  It represents the division of the coordinates of a {\b point} for a scalar. Implemented using operator*. }{\comment (endMemberDescription)}
}}
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\comment Begin SubSubSection}
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<unsigned int dim, typename Storage_t = double> class BGLgeom::point< dim, Storage_t >{\comment (newParagraph)}
\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class template for storing the vertex coordinates in n-dimentional space. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Constructors and set method are implemented with std::initializer_list, so they have to be called with: method(\{args\}) \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid {\i dim} Template argument that specifies the dimension of the space \par
{\i Storage_t} Template argument that specifies the precision type for the coordinates \par
}
}{\comment endTextBlock}
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\comment (startItemList level=0) }
{{\comment (startItemListItem)}
{\comment (newParagraph)}
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
include/{\b generic_point.hpp}{\comment (endItemListItem)}
{\comment (newParagraph)}
\par
{\comment (endItemList level=1)}
}{\comment endFile}
{\comment end include classBGLgeom_1_1point.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include classreader__base__class.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
reader_base_class< Graph > Class Template Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v reader_base_class}
{\xe \v reader_base_class}
{\comment writeAnchor (classreader__base__class)}
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
{\comment startClassDiagram }
Inheritance diagram for reader_base_class< Graph >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classreader__base__class.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

typedef boost::graph_traits< Graph >::vertex_descriptor {\b Vertex_desc}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAHZ}
{\bkmkend AAAAAAAAHZ}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

typedef boost::graph_traits< Graph >::edge_descriptor {\b Edge_desc}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAIA}
{\bkmkend AAAAAAAAIA}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b reader_base_class} (Graph &_G){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAIB}
{\bkmkend AAAAAAAAIB}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default constructor (we need however to initialize the reference). }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b reader_base_class} (Graph &_G, std::string _file_name, unsigned int _num_dummy_lines){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAIC}
{\bkmkend AAAAAAAAIC}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor: assign only num_dummy_lines, empty graph. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b reader_base_class} ({\b reader_base_class} const &){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAID}
{\bkmkend AAAAAAAAID}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default copy constructor. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b reader_base_class} & {\b operator=} ({\b reader_base_class} const &){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAIE}
{\bkmkend AAAAAAAAIE}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Assignement operator. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual {\b ~reader_base_class} (){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAIF}
{\bkmkend AAAAAAAAIF}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor (needed?). }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual void {\b set_input_file} (std::string _file_name){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAIG}
{\bkmkend AAAAAAAAIG}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It allows to set the input file. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual void {\b set_num_dummy_lines} (unsigned int const &_num_dummy_lines){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAIH}
{\bkmkend AAAAAAAAIH}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It allows to set both num_dummy_lines and current_line_number (they must have the same value). }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual void {\b read_input_file} (){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAII}
{\bkmkend AAAAAAAAII}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Read the input file. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual void {\b ignore_dummy_lines} (std::ifstream &file){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAIJ}
{\bkmkend AAAAAAAAIJ}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It ignores the first n lines, that are headers, in the input file. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual void {\b read_data_from_line} (std::istringstream &temp)=0{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAIK}
{\bkmkend AAAAAAAAIK}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It describes how to read each line in the input file, and in which variables to store the data. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual void {\b build_graph} ()=0{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAIL}
{\bkmkend AAAAAAAAIL}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It build the graph one edge at a time, called many times from an external loop. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual void {\b give_new_source_properties} ()=0{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAIM}
{\bkmkend AAAAAAAAIM}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It assigns properties to new_source in the rigth way. It has to be called in {\b build_graph()}! }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual void {\b give_new_target_properties} ()=0{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAIN}
{\bkmkend AAAAAAAAIN}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It assigns properties to new_target in the right way. It has to be called in {\b build_graph()}! }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual void {\b give_new_edge_properties} ()=0{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAIO}
{\bkmkend AAAAAAAAIO}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It assigns properties to new_edge in the rigth way. It has to be called in {\b build_graph()}! }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual void {\b if_edge_not_inserted} (){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAIP}
{\bkmkend AAAAAAAAIP}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It deals with wrong insertion of an edge.  It can be called only after a call to boost::add_edge with the pair <Edge_desc, bool> as return value. In this way the value of edge_inserted is set up. }{\comment (endMemberDescription)}
}}
{\comment (endMemberList) }
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

Graph & {\b G}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAIQ}
{\bkmkend AAAAAAAAIQ}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A reference is used to represent the Graph.  Using a reference allows us not to copy the whole graph outside the class once finished to read data and to build the graph. In this way we build the pre-existent graph (created in the main) while reading the input file. We do not use extra memory. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

std::string {\b file_name}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAIR}
{\bkmkend AAAAAAAAIR}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The string in which is stored the name of the input file to read. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

unsigned int {\b num_dummy_lines}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAIS}
{\bkmkend AAAAAAAAIS}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The numbers of initial lines (headers) that the reader has to skip to read useful data. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

std::string {\b line}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAIT}
{\bkmkend AAAAAAAAIT}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This will contain one line of the input file, to parse. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

Vertex_desc {\b new_source}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAIU}
{\bkmkend AAAAAAAAIU}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The vertex descriptor for the source of the new edge added. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

Vertex_desc {\b new_target}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAIV}
{\bkmkend AAAAAAAAIV}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The vertex descriptor for the target of the new edge added. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

Edge_desc {\b new_edge}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAIW}
{\bkmkend AAAAAAAAIW}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The edge descriptor for the new edge. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

bool {\b edge_inserted}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAIX}
{\bkmkend AAAAAAAAIX}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Bool returned in a pair with an edge descriptor by add_edge function.  The value is assigned when trying to insert an edge in the graph. It is set to true if the edge was succesfully inserted, false otherwise. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

unsigned int {\b current_line_number}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAIY}
{\bkmkend AAAAAAAAIY}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It tracks the current line of the input file. }{\comment (endMemberDescription)}
}}
{\comment (endMemberList) }
}

{\comment Begin SubSubSection}
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename Graph> class reader_base_class< Graph >{\comment (newParagraph)}
\par
}

{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\comment (startItemList level=0) }
{{\comment (startItemListItem)}
{\comment (newParagraph)}
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
include/{\b reader_base_class.hpp}{\comment (endItemListItem)}
{\comment (newParagraph)}
\par
{\comment (endItemList level=1)}
}{\comment endFile}
{\comment end include classreader__base__class.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include structvertex__data__structure.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
vertex_data_structure< dim > Struct Template Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v vertex_data_structure}
{\xe \v vertex_data_structure}
{\comment writeAnchor (structvertex__data__structure)}
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

unsigned int {\b vertex_id} = 0{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAIZ}
{\bkmkend AAAAAAAAIZ}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

std::string {\b label} = ""{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAJA}
{\bkmkend AAAAAAAAJA}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

point< dim > {\b coord}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAJB}
{\bkmkend AAAAAAAAJB}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}

{\comment Begin SubSubSection}
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<unsigned int dim> struct vertex_data_structure< dim >{\comment (newParagraph)}
\par
}

{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\comment (startItemList level=0) }
{{\comment (startItemListItem)}
{\comment (newParagraph)}
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
include/{\b data_structure.hpp}{\comment (endItemListItem)}
{\comment (newParagraph)}
\par
{\comment (endItemList level=1)}
}{\comment endFile}
{\comment end include structvertex__data__structure.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include structZunino__edge__data.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Zunino_edge_data Struct Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v Zunino_edge_data}
{\xe \v Zunino_edge_data}
{\comment writeAnchor (structZunino__edge__data)}
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

double {\b capacity}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAJC}
{\bkmkend AAAAAAAAJC}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

double {\b length}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAJD}
{\bkmkend AAAAAAAAJD}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\comment (startItemList level=0) }
{{\comment (startItemListItem)}
{\comment (newParagraph)}
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
include/{\b new_reader_Zunino.hpp}{\comment (endItemListItem)}
{\comment (newParagraph)}
\par
{\comment (endItemList level=1)}
}{\comment endFile}
{\comment end include structZunino__edge__data.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include structZunino__edge__property__t.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Zunino_edge_property_t Struct Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v Zunino_edge_property_t}
{\xe \v Zunino_edge_property_t}
{\comment writeAnchor (structZunino__edge__property__t)}
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

double {\b capacity}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAJE}
{\bkmkend AAAAAAAAJE}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

double {\b length}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAJF}
{\bkmkend AAAAAAAAJF}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\comment (startItemList level=0) }
{{\comment (startItemListItem)}
{\comment (newParagraph)}
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
include/{\b Zunino_edge_property.hpp}{\comment (endItemListItem)}
{\comment (newParagraph)}
\par
{\comment (endItemList level=1)}
}{\comment endFile}
{\comment end include structZunino__edge__property__t.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include classZunino__reader.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Zunino_reader< Zunino_source_data, Zunino_target_data, Zunino_edge_data, Zunino_topological_data > Class Template Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v Zunino_reader}
{\xe \v Zunino_reader}
{\comment writeAnchor (classZunino__reader)}
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
{\comment startClassDiagram }
Inheritance diagram for Zunino_reader< Zunino_source_data, Zunino_target_data, Zunino_edge_data, Zunino_topological_data >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classZunino__reader.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual void {\b get_data_from_line} (){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAJG}
{\bkmkend AAAAAAAAJG}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads the data from one single line. It has to be specified by the user  It reads data form the istringstream iss_line that is defined as an attribute of the class and it is updated after every call of {\b read_line()}. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual {\b Zunino_source_data} {\b get_source_data} (){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAJH}
{\bkmkend AAAAAAAAJH}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A method to get the right data to append to the source. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual {\b Zunino_target_data} {\b get_target_data} (){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAJI}
{\bkmkend AAAAAAAAJI}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A method to get the right data to append to the target. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual {\b Zunino_edge_data} {\b get_edge_data} (){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAJJ}
{\bkmkend AAAAAAAAJJ}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A method to get the right data to append to an edge. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual {\b Zunino_topological_data} {\b get_topologica_data} (){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAJK}
{\bkmkend AAAAAAAAJK}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}

{\comment Begin SubSubSection}
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename Zunino_source_data, typename Zunino_target_data, typename Zunino_edge_data, typename Zunino_topological_data> class Zunino_reader< Zunino_source_data, Zunino_target_data, Zunino_edge_data, Zunino_topological_data >{\comment (newParagraph)}
\par
}

{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\comment (startItemList level=0) }
{{\comment (startItemListItem)}
{\comment (newParagraph)}
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
include/{\b new_reader_Zunino.hpp}{\comment (endItemListItem)}
{\comment (newParagraph)}
\par
{\comment (endItemList level=1)}
}{\comment endFile}
{\comment end include classZunino__reader.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include structZunino__source__data.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Zunino_source_data Struct Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v Zunino_source_data}
{\xe \v Zunino_source_data}
{\comment writeAnchor (structZunino__source__data)}
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b BGLgeom::point}< 3 > {\b SRC}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAJL}
{\bkmkend AAAAAAAAJL}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\comment (startItemList level=0) }
{{\comment (startItemListItem)}
{\comment (newParagraph)}
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
include/{\b new_reader_Zunino.hpp}{\comment (endItemListItem)}
{\comment (newParagraph)}
\par
{\comment (endItemList level=1)}
}{\comment endFile}
{\comment end include structZunino__source__data.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include structZunino__target__data.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Zunino_target_data Struct Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v Zunino_target_data}
{\xe \v Zunino_target_data}
{\comment writeAnchor (structZunino__target__data)}
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b BGLgeom::point}< 3 > {\b TGT}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAJM}
{\bkmkend AAAAAAAAJM}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\comment (startItemList level=0) }
{{\comment (startItemListItem)}
{\comment (newParagraph)}
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
include/{\b new_reader_Zunino.hpp}{\comment (endItemListItem)}
{\comment (newParagraph)}
\par
{\comment (endItemList level=1)}
}{\comment endFile}
{\comment end include structZunino__target__data.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include structZunino__topological__data.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Zunino_topological_data Struct Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v Zunino_topological_data}
{\xe \v Zunino_topological_data}
{\comment writeAnchor (structZunino__topological__data)}
{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

unsigned int {\b src}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAJN}
{\bkmkend AAAAAAAAJN}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

unsigned int {\b tgt}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAJO}
{\bkmkend AAAAAAAAJO}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\comment (startItemList level=0) }
{{\comment (startItemListItem)}
{\comment (newParagraph)}
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
include/{\b new_reader_Zunino.hpp}{\comment (endItemListItem)}
{\comment (newParagraph)}
\par
{\comment (endItemList level=1)}
}{\comment endFile}
{\comment end include structZunino__topological__data.rtf}

{\comment BeginRTFChapter}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Documentation{\tc \v File Documentation}
\par \pard\plain 
{\comment begin include compute__euclidean__distance_8hpp.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
include/compute_euclidean_distance.hpp File Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v include/compute_euclidean_distance.hpp}
{\xe \v include/compute_euclidean_distance.hpp}
{\comment writeAnchor (compute__euclidean__distance_8hpp)}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes the euclidean distance between two given vertices. }{\comment endParagraph}
}\par
{\comment startTextBlock}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "compute_euclidean_distance_imp.hpp"}{\comment (lineBreak)}
\par
{\comment endTextBlock}
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

template<typename Graph > double {\b compute_euclidean_distance} (typename boost::graph_traits< Graph >::vertex_descriptor a, typename boost::graph_traits< Graph >::vertex_descriptor b, Graph const &G){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes the euclidean distance between two given vertices. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Ilaria Speranza & Mattia Tantardini \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Sep 2016. \par
}}{\comment endTextBlock}
}
{\comment endFile}
{\comment end include compute__euclidean__distance_8hpp.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include data__structure_8hpp.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
include/data_structure.hpp File Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v include/data_structure.hpp}
{\xe \v include/data_structure.hpp}
{\comment writeAnchor (data__structure_8hpp)}
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Declaration of generic data structure to represent vertex and edge properties. }{\comment endParagraph}
}\par
{\comment startTextBlock}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "user_data_structure.hpp"}{\comment (lineBreak)}
\par
{\f2 #include <string>}{\comment (lineBreak)}
\par
{\f2 #include "generic_edge_geometry.hpp"}{\comment (lineBreak)}
\par
{\f2 #include "generic_point.hpp"}{\comment (lineBreak)}
\par
{\comment endTextBlock}
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b data_structure< Edge_data_structure, Vertex_data_structure >}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An abstract class to handle the user definition data structure  The users has to specify, in the derived class, all variables he need in order to store information read from the input file. Then, through the definition of Edge_data_structure and Vertex_data_structure, he can get separately all the information to put on edges and vertices. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b my_edge}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b edge_data_structure< dim >}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b vertex_data_structure< dim >}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b data_structure< Edge_data_structure, Vertex_data_structure >}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An abstract class to handle the user definition data structure  The users has to specify, in the derived class, all variables he need in order to store information read from the input file. Then, through the definition of Edge_data_structure and Vertex_data_structure, he can get separately all the information to put on edges and vertices. }{\comment (endMemberDescription)}
}}
{\comment (endMemberList) }
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b get_data_from_line} (std::ifstream &in, {\b data_structure} &D){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

virtual read_file {\b my_edge} {\b get_edge_data} (){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

struct {\b my_edge} {\b length}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

point {\b coord}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Declaration of generic data structure to represent vertex and edge properties. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Ilaria Speranza & Mattia Tantardini \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Sept, 2016 \par
}}{\comment endTextBlock}
}
{\comment endFile}
{\comment end include data__structure_8hpp.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include dijkstra_8hpp.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
include/dijkstra.hpp File Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v include/dijkstra.hpp}
{\xe \v include/dijkstra.hpp}
{\comment writeAnchor (dijkstra_8hpp)}
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Solves the single-source shortest-paths problem on a weighted, directed graph with non-negative edge weights.  This function takes in input the graph, the source vertex and two vectors, one for the distance map and the other for the predecessor map, which will be filled with the results of the algorithm. }{\comment endParagraph}
}\par
{\comment startTextBlock}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "boost/graph/dijkstra_shortest_paths.hpp"}{\comment (lineBreak)}
\par
{\f2 #include "Zunino_edge_property.hpp"}{\comment (lineBreak)}
\par
{\f2 #include "dijkstra_imp.hpp"}{\comment (lineBreak)}
\par
{\comment endTextBlock}
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

template<typename Graph > void {\b dijkstra} (Graph const &G, typename boost::graph_traits< Graph >::vertex_descriptor const &v, std::vector< int > &distances, std::vector< typename boost::graph_traits< Graph >::vertex_descriptor > &predecessors){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Solves the single-source shortest-paths problem on a weighted, directed graph with non-negative edge weights.  This function takes in input the graph, the source vertex and two vectors, one for the distance map and the other for the predecessor map, which will be filled with the results of the algorithm. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Ilaria Speranza & Mattia Tantardini \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Oct 2016. \par
}}{\comment endTextBlock}
}
{\comment endFile}
{\comment end include dijkstra_8hpp.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include dijkstra__imp_8hpp.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
include/dijkstra_imp.hpp File Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v include/dijkstra_imp.hpp}
{\xe \v include/dijkstra_imp.hpp}
{\comment writeAnchor (dijkstra__imp_8hpp)}
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Solves the single-source shortest-paths problem on a weighted, directed graph with non-negative edge weights. . }{\comment endParagraph}
}\par
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

template<typename Graph > void {\b dijkstra} (Graph const &G, typename boost::graph_traits< Graph >::vertex_descriptor const &v, std::vector< int > &distances, std::vector< typename boost::graph_traits< Graph >::vertex_descriptor > &predecessors){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Solves the single-source shortest-paths problem on a weighted, directed graph with non-negative edge weights. . \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Ilaria Speranza & Mattia Tantardini \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Oct 2016. \par
}}{\comment endTextBlock}
}
{\comment endFile}
{\comment end include dijkstra__imp_8hpp.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include disjoint__components_8hpp.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
include/disjoint_components.hpp File Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v include/disjoint_components.hpp}
{\xe \v include/disjoint_components.hpp}
{\comment writeAnchor (disjoint__components_8hpp)}
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Identifies if there are fully disconnected subgraphs.. . }{\comment endParagraph}
}\par
{\comment startTextBlock}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <map>}{\comment (lineBreak)}
\par
{\f2 #include <tuple>}{\comment (lineBreak)}
\par
{\f2 #include <iostream>}{\comment (lineBreak)}
\par
{\f2 #include <boost/graph/graph_traits.hpp>}{\comment (lineBreak)}
\par
{\f2 #include "our_disjoint_sets.hpp"}{\comment (lineBreak)}
\par
{\f2 #include "disjoint_components_imp.hpp"}{\comment (lineBreak)}
\par
{\comment endTextBlock}
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Graph > void {\b disjoint_components} (Graph &G){\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Identifies if there are fully disconnected subgraphs.. . \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Ilaria Speranza & Mattia Tantardini \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Sep 2016. \par
}}{\comment endTextBlock}
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation{\comment endGroupHeader}
\par
\pard\plain 
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v disjoint_components\:disjoint_components.hpp}
{\xe \v disjoint_components.hpp\:disjoint_components}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Graph > void disjoint_components ({\comment (startParameterList)}
Graph & {\i G}){\f2  [inline]}{\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given a graph, this function checks whether there are fully disconnected subgraphs, i.e. subgraphs with no edge connecting each other. It returns a map which associates each vertex with an integer identifying the subgraph it belongs to. \par
}}
{\comment endFile}
{\comment end include disjoint__components_8hpp.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include disjoint__components__imp_8hpp.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
include/disjoint_components_imp.hpp File Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v include/disjoint_components_imp.hpp}
{\xe \v include/disjoint_components_imp.hpp}
{\comment writeAnchor (disjoint__components__imp_8hpp)}
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Identifies if there are fully disconnected subgraphs. }{\comment endParagraph}
}\par
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Graph > void {\b disjoint_components} (Graph &G){\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Identifies if there are fully disconnected subgraphs. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Ilaria Speranza & Mattia Tantardini \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Sep 2016.  Note: the algorithm is not very well. It can be bettered, in particular when changing all the labels of a big component that we have to move in another small component. Better to move the smaller into the bigger. \par
}}{\comment endTextBlock}
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation{\comment endGroupHeader}
\par
\pard\plain 
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v disjoint_components\:disjoint_components_imp.hpp}
{\xe \v disjoint_components_imp.hpp\:disjoint_components}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Graph > void disjoint_components ({\comment (startParameterList)}
Graph & {\i G}){\f2  [inline]}{\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given a graph, this function checks whether there are fully disconnected subgraphs, i.e. subgraphs with no edge connecting each other. It returns a map which associates each vertex with an integer identifying the subgraph it belongs to. \par
}}
{\comment endFile}
{\comment end include disjoint__components__imp_8hpp.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include edge__geometry_8hpp.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
include/edge_geometry.hpp File Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v include/edge_geometry.hpp}
{\xe \v include/edge_geometry.hpp}
{\comment writeAnchor (edge__geometry_8hpp)}
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Virtual base class for the geometry of an edge . }{\comment endParagraph}
}\par
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b BGLgeom::edge_geometry< dim >}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Virtual base class for the geometry of an edge . \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Ilaria Speranza & Mattia Tantardini \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Sept, 2016 \par
}}{\comment endTextBlock}
}
{\comment endFile}
{\comment end include edge__geometry_8hpp.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include Forma__edge__property_8hpp.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
include/Forma_edge_property.hpp File Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v include/Forma_edge_property.hpp}
{\xe \v include/Forma_edge_property.hpp}
{\comment writeAnchor (Forma__edge__property_8hpp)}
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This contains the struct for edge properties that has to be used for Formaggia's example . }{\comment endParagraph}
}\par
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b edge_parametrization}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class holds the parametrization of the edge. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Forma_edge_property_t}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This contains the struct for edge properties that has to be used for Formaggia's example . \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Ilaria Speranza & Mattia Tantardini \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Sept, 2016 \par
}}{\comment endTextBlock}
}
{\comment endFile}
{\comment end include Forma__edge__property_8hpp.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include Forma__vertex__property_8hpp.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
include/Forma_vertex_property.hpp File Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v include/Forma_vertex_property.hpp}
{\xe \v include/Forma_vertex_property.hpp}
{\comment writeAnchor (Forma__vertex__property_8hpp)}
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This contains the struct for vertex properties that has to be used for Formaggia's example . }{\comment endParagraph}
}\par
{\comment startTextBlock}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "generic_point.hpp"}{\comment (lineBreak)}
\par
{\comment endTextBlock}
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Forma_vertex_property_t}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This struct contains the vertex property for Formaggia's example. }{\comment (endMemberDescription)}
}}
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This contains the struct for vertex properties that has to be used for Formaggia's example . \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Ilaria Speranza & Mattia Tantardini \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Sept, 2016 \par
}}{\comment endTextBlock}
}
{\comment endFile}
{\comment end include Forma__vertex__property_8hpp.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include generic__edge__geometry_8hpp.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
include/generic_edge_geometry.hpp File Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v include/generic_edge_geometry.hpp}
{\xe \v include/generic_edge_geometry.hpp}
{\comment writeAnchor (generic__edge__geometry_8hpp)}
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class for circular geometry of an edge . }{\comment endParagraph}
}\par
{\comment startTextBlock}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <array>}{\comment (lineBreak)}
\par
{\f2 #include <functional>}{\comment (lineBreak)}
\par
{\f2 #include "generic_point.hpp"}{\comment (lineBreak)}
\par
{\f2 #include "edge_geometry.hpp"}{\comment (lineBreak)}
\par
{\comment endTextBlock}
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b BGLgeom::generic_edge_geometry< dim >}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class for circular geometry of an edge . \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
class for the generic geometry of an edge \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Ilaria Speranza & Mattia Tantardini \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Sept, 2016 \par
}}{\comment endTextBlock}
}
{\comment endFile}
{\comment end include generic__edge__geometry_8hpp.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include generic__point_8hpp.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
include/generic_point.hpp File Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v include/generic_point.hpp}
{\xe \v include/generic_point.hpp}
{\comment writeAnchor (generic__point_8hpp)}
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Templete class to handle points in 2D or 3D (or even greater). }{\comment endParagraph}
}\par
{\comment startTextBlock}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <array>}{\comment (lineBreak)}
\par
{\f2 #include <iostream>}{\comment (lineBreak)}
\par
{\f2 #include <initializer_list>}{\comment (lineBreak)}
\par
{\f2 #include <type_traits>}{\comment (lineBreak)}
\par
{\comment endTextBlock}
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b BGLgeom::point< dim, Storage_t >}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class template for storing the vertex coordinates in n-dimentional space. }{\comment (endMemberDescription)}
}}
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Templete class to handle points in 2D or 3D (or even greater). \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Ilaria Speranza and Mattia Tantardini \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Sept, 2016 \par
}}{\comment endTextBlock}
}
{\comment endFile}
{\comment end include generic__point_8hpp.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include graph__builder_8hpp.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
include/graph_builder.hpp File Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v include/graph_builder.hpp}
{\xe \v include/graph_builder.hpp}
{\comment writeAnchor (graph__builder_8hpp)}
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Utilities to build a graph. }{\comment endParagraph}
}\par
{\comment startTextBlock}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <vector>}{\comment (lineBreak)}
\par
{\f2 #include <boost/graph/graph_traits.hpp>}{\comment (lineBreak)}
\par
{\f2 #include "generic_point.hpp"}{\comment (lineBreak)}
\par
{\comment endTextBlock}
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

template<typename Graph , typename Source_data_structure > void {\b give_source_properties} (Source_data_structure const &D, boost::graph_traits< Graph >::vertex_descriptor const &v, Graph &G){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Giving to source node v all properties through assigning the Source_data_structure. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

template<typename Graph , typename Target_data_structure > void {\b give_target_properties} (Target_data_structure const &D, boost::graph_traits< Graph >::vertex_descriptor const &v, Graph &G){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Giving to target node v all properties through assigning the Target_data_structure. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

template<typename Graph , typename Edge_data_structure > void {\b give_edge_properties} (Edge_data_structure const &D, boost::graph_traits< Graph >::edge_descriptor const &e, Graph &G){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Giving to edge e all properties through assigning the Edge_data_structure. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

template<typename Graph , typename Vertex_data_structure , typename Edge_data_structure , typename Intersections_container  = std::vector<point<2>>> void {\b refine_graph} (Graph &G, Intersections_container const &I, boost::graph_traits< Graph >::edge_descriptor edge1, boost::graph_traits< Graph >::edge_descriptor edge2){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Utilities to build a graph. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Ilaria Speranza & Mattia Tantardini \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Sept, 2016 \par
}}{\comment endTextBlock}
}
{\comment endFile}
{\comment end include graph__builder_8hpp.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include intersector__base__class_8hpp.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
include/intersector_base_class.hpp File Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v include/intersector_base_class.hpp}
{\xe \v include/intersector_base_class.hpp}
{\comment writeAnchor (intersector__base__class_8hpp)}
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Abstract class to handle intersections of edges in a graph with geometrical properties  It contains also some utilities needed to compute the intersection between two (linear) edges. }{\comment endParagraph}
}\par
{\comment startTextBlock}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <vector>}{\comment (lineBreak)}
\par
{\f2 #include <array>}{\comment (lineBreak)}
\par
{\f2 #include <tuple>}{\comment (lineBreak)}
\par
{\f2 #include <cmath>}{\comment (lineBreak)}
\par
{\f2 #include <limits>}{\comment (lineBreak)}
\par
{\f2 #include <boost/graph/graph_traits.hpp>}{\comment (lineBreak)}
\par
{\f2 #include "generic_point.hpp"}{\comment (lineBreak)}
\par
{\comment endTextBlock}
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Geometry::Linear_edge}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A simple class that hanlde a linear edge  This class is thought to manage the description of the geometry of a linear edge, in order to compute intersections. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Geometry::Intersection}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A simple struct that contains the result of the intersection test. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b intersector_base_class< Graph >}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

typedef std::array< double, 2 > {\b Vector}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Ecco il trucco forse!!! Una volta stabilita tutta la geometria, questa classe dovrebbe funzionare sempre allo stesso modo. Cio\'E8\'2C tipo: le intersezioni si troveranno sempre nella stessa maniera, i punti e gli edge saranno tutti descritti alla stessa maniera, ecc. }{\comment (endMemberDescription)}
}}
{\comment (endMemberList) }
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Edge_rapresentation_t  = Linear_edge> Intersection {\b Geometry::compute_intersection} (Linear_edge const &Edge1, Linear_edge const &Edge2, double const tol=20 *std::numeric_limits< double >::epsilon()){\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Function to compute intersection between two linear edges. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

std::ostream & {\b Geometry::operator<<} (std::ostream &out, {\b Geometry::Intersection} const &i){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overload of operator<< to show the information contained in the strcut {\b Intersection}. }{\comment (endMemberDescription)}
}}
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Abstract class to handle intersections of edges in a graph with geometrical properties  It contains also some utilities needed to compute the intersection between two (linear) edges. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Ilaria Speranza & Mattia Tantardini \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Sept, 2016 \par
}}{\comment endTextBlock}
}
{\comment endFile}
{\comment end include intersector__base__class_8hpp.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include io__graph_8hpp.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
include/io_graph.hpp File Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v include/io_graph.hpp}
{\xe \v include/io_graph.hpp}
{\comment writeAnchor (io__graph_8hpp)}
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Declaration of functions related to input and output of the graph. }{\comment endParagraph}
}\par
{\comment startTextBlock}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <tuple>}{\comment (lineBreak)}
\par
{\f2 #include <boost/graph/adjacency_list.hpp>}{\comment (lineBreak)}
\par
{\f2 #include <iostream>}{\comment (lineBreak)}
\par
{\f2 #include <sstream>}{\comment (lineBreak)}
\par
{\f2 #include <string>}{\comment (lineBreak)}
\par
{\f2 #include <fstream>}{\comment (lineBreak)}
\par
{\f2 #include <set>}{\comment (lineBreak)}
\par
{\f2 #include <utility>}{\comment (lineBreak)}
\par
{\f2 #include <cmath>}{\comment (lineBreak)}
\par
{\f2 #include <algorithm>}{\comment (lineBreak)}
\par
{\f2 #include "Forma_vertex_property.hpp"}{\comment (lineBreak)}
\par
{\f2 #include "Forma_edge_property.hpp"}{\comment (lineBreak)}
\par
{\f2 #include "generic_point.hpp"}{\comment (lineBreak)}
\par
{\f2 #include "io_graph_imp.hpp"}{\comment (lineBreak)}
\par
{\comment endTextBlock}
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

template<typename Graph , typename Reader > void {\b read_input_file} (Graph &G, Reader R, std::string file_name){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Graph > void {\b read_zunino_old_format} (Graph &G, std::string file_name){\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads data about the graph from the input file given by professor Zunino. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

template<typename Graph > void {\b read_Formaggia_format} (Graph &G, std::string file_name){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Graph > boost::graph_traits< Graph >::vertex_descriptor {\b vertex_insertion_or_identification} (Graph &G, point< 2 > const &P){\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Helper function for read_Formaggia_format. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Graph > void {\b check_for_intersections} (std::vector< std::pair< point< 2 >, typename boost::graph_traits< Graph >::edge_descriptor > > &v, point< 2 > const &SRC, point< 2 > const &TGT, Graph const &G){\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Helper function for read_Formaggia_format. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Graph , bool src_less_than_tgt> bool {\b compare} (std::pair< point< 2 >, typename boost::graph_traits< Graph >::edge_descriptor > pair1, std::pair< point< 2 >, typename boost::graph_traits< Graph >::edge_descriptor > pair2){\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Helper function for check_for intersection. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::pair< bool, point< 2 > > {\b are_intersected} (std::pair< point< 2 >, point< 2 > > line1, std::pair< point< 2 >, point< 2 > > line2){\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
helper function for check_for_intersection }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Graph > void {\b refine_graph} (Graph &G, typename std::vector< std::pair< point< 2 >, typename boost::graph_traits< Graph >::edge_descriptor > > const &vect, int frac_number, typename boost::graph_traits< Graph >::vertex_descriptor src, typename boost::graph_traits< Graph >::vertex_descriptor tgt){\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Helper function for read_Formaggia_format. }{\comment (endMemberDescription)}
}}
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Declaration of functions related to input and output of the graph. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Ilaria Speranza & Mattia Tantardini \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Sept, 2016 \par
}}{\comment endTextBlock}
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation{\comment endGroupHeader}
\par
\pard\plain 
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v are_intersected\:io_graph.hpp}
{\xe \v io_graph.hpp\:are_intersected}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::pair<bool, point<2> > are_intersected ({\comment (startParameterList)}
std::pair< point< 2 >, point< 2 > > {\i line1}, {\comment (startParameterList)}
  std::pair< point< 2 >, point< 2 > > {\i line2}){\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
helper function for check_for_intersection }{\comment endParagraph}
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
we assume the fractures can only be vertical or horizontal. It compute the coordinates of the intersection point, if present. \par
}}
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v check_for_intersections\:io_graph.hpp}
{\xe \v io_graph.hpp\:check_for_intersections}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Graph > void check_for_intersections ({\comment (startParameterList)}
std::vector< std::pair< point< 2 >, typename boost::graph_traits< Graph >::edge_descriptor > > & {\i v}, {\comment (startParameterList)}
  point< 2 > const & {\i SRC}, {\comment (startParameterList)}
  point< 2 > const & {\i TGT}, {\comment (startParameterList)}
  Graph const & {\i G}){\f2  [inline]}{\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Helper function for read_Formaggia_format. }{\comment endParagraph}
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function checks if two lines (fractures) are intersected. If yes, it creates a vector with all the intersection points already ordered with the right direction (from source to target vertex)\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i vect} The vector that will be filled with the intersection points of each new edge \par
{\i SRC} Source vertex of the current edge \par
{\i TGT} Target vertex of the current edge \par
{\i G} Graph \par
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid void \par
}}}
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v compare\:io_graph.hpp}
{\xe \v io_graph.hpp\:compare}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Graph , bool src_less_than_tgt> bool compare ({\comment (startParameterList)}
std::pair< point< 2 >, typename boost::graph_traits< Graph >::edge_descriptor > {\i pair1}, {\comment (startParameterList)}
  std::pair< point< 2 >, typename boost::graph_traits< Graph >::edge_descriptor > {\i pair2}){\f2  [inline]}{\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Helper function for check_for intersection. }{\comment endParagraph}
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given a couple of points, this function orders the intersection points according to the template parameter src_less_than_tgt. The ordering is needed in order to craete the new edges in the right way, preserving the direction of the fractures.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i pair1} It is the intersection point between the current edge and the edge described by the second component of the pair \par
{\i pair2} It is the intersection point between the current edge and the edge described by the second component of the pair \par
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid bool \par
}}}
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v read_zunino_old_format\:io_graph.hpp}
{\xe \v io_graph.hpp\:read_zunino_old_format}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Graph > void read_zunino_old_format ({\comment (startParameterList)}
Graph & {\i G}, {\comment (startParameterList)}
  std::string {\i file_name}){\f2  [inline]}{\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads data about the graph from the input file given by professor Zunino. }{\comment endParagraph}
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The funcitions reads from a file where data is written as: \par line1: description of file \par line2: description of file \par from line 3: line_number - source - target - diameter - length - source_coord - target_coord \par
}}
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v refine_graph\:io_graph.hpp}
{\xe \v io_graph.hpp\:refine_graph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Graph > void refine_graph ({\comment (startParameterList)}
Graph & {\i G}, {\comment (startParameterList)}
  typename std::vector< std::pair< point< 2 >, typename boost::graph_traits< Graph >::edge_descriptor > > const & {\i vect}, {\comment (startParameterList)}
  int {\i frac_number}, {\comment (startParameterList)}
  typename boost::graph_traits< Graph >::vertex_descriptor {\i src}, {\comment (startParameterList)}
  typename boost::graph_traits< Graph >::vertex_descriptor {\i tgt}){\f2  [inline]}{\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Helper function for read_Formaggia_format. }{\comment endParagraph}
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function breaks old edges to create a refined graph according to the intersection points found while inserting the current edge. It preserves the fracture number of each old edge while creating the new ones.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i G} Graph \par
{\i vect} The vector of the intersection points \par
{\i frac_number} The fracture number of the current edge \par
{\i src} Vertex descriptor of the source of the current edge \par
{\i tgt} Vertex descriptor of the target of the current edge \par
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid void \par
}}}
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v vertex_insertion_or_identification\:io_graph.hpp}
{\xe \v io_graph.hpp\:vertex_insertion_or_identification}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Graph > boost::graph_traits<Graph>::vertex_descriptor vertex_insertion_or_identification ({\comment (startParameterList)}
Graph & {\i G}, {\comment (startParameterList)}
  point< 2 > const & {\i P}){\f2  [inline]}{\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Helper function for read_Formaggia_format. }{\comment endParagraph}
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The function checks if the vertex we are trying to insert is already present in the graph, (in this case it will be ignored) or if it isn't already present (in this case it will be inserted).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i G} Graph we are constructing \par
{\i P} Point we want to check if is present or not \par
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid vertex_descriptor \par
}}}
{\comment endFile}
{\comment end include io__graph_8hpp.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include io__graph__imp_8hpp.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
include/io_graph_imp.hpp File Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v include/io_graph_imp.hpp}
{\xe \v include/io_graph_imp.hpp}
{\comment writeAnchor (io__graph__imp_8hpp)}
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Definition of functions related to input and output of the graph. }{\comment endParagraph}
}\par
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

template<typename Graph > void {\b read_Formaggia_format} (Graph &G, std::string file_name){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Graph > boost::graph_traits< Graph >::vertex_descriptor {\b vertex_insertion_or_identification} (Graph &G, point< 2 > const &P){\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Helper function for read_Formaggia_format. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Graph > void {\b check_for_intersections} (std::vector< std::pair< point< 2 >, typename boost::graph_traits< Graph >::edge_descriptor > > &vect, point< 2 > const &SRC, point< 2 > const &TGT, Graph const &G){\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Helper function for read_Formaggia_format. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Graph , bool src_less_than_tgt> bool {\b compare} (std::pair< point< 2 >, typename boost::graph_traits< Graph >::edge_descriptor > pair1, std::pair< point< 2 >, typename boost::graph_traits< Graph >::edge_descriptor > pair2){\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Helper function for check_for intersection. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::pair< bool, point< 2 > > {\b are_intersected} (std::pair< point< 2 >, point< 2 > > line1, std::pair< point< 2 >, point< 2 > > line2){\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
helper function for check_for_intersection }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Graph > void {\b refine_graph} (Graph &G, typename std::vector< std::pair< point< 2 >, typename boost::graph_traits< Graph >::edge_descriptor > > const &vect, int frac_number, typename boost::graph_traits< Graph >::vertex_descriptor src, typename boost::graph_traits< Graph >::vertex_descriptor tgt){\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Helper function for read_Formaggia_format. }{\comment (endMemberDescription)}
}}
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Definition of functions related to input and output of the graph. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Ilaria Speranza & Mattia Tantardini \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Sept, 2016 \par
}}{\comment endTextBlock}
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation{\comment endGroupHeader}
\par
\pard\plain 
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v are_intersected\:io_graph_imp.hpp}
{\xe \v io_graph_imp.hpp\:are_intersected}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::pair<bool, point<2> > are_intersected ({\comment (startParameterList)}
std::pair< point< 2 >, point< 2 > > {\i line1}, {\comment (startParameterList)}
  std::pair< point< 2 >, point< 2 > > {\i line2}){\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
helper function for check_for_intersection }{\comment endParagraph}
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
we assume the fractures can only be vertical or horizontal. It compute the coordinates of the intersection point, if present. \par
}}
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v check_for_intersections\:io_graph_imp.hpp}
{\xe \v io_graph_imp.hpp\:check_for_intersections}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Graph > void check_for_intersections ({\comment (startParameterList)}
std::vector< std::pair< point< 2 >, typename boost::graph_traits< Graph >::edge_descriptor > > & {\i v}, {\comment (startParameterList)}
  point< 2 > const & {\i SRC}, {\comment (startParameterList)}
  point< 2 > const & {\i TGT}, {\comment (startParameterList)}
  Graph const & {\i G}){\f2  [inline]}{\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Helper function for read_Formaggia_format. }{\comment endParagraph}
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function checks if two lines (fractures) are intersected. If yes, it creates a vector with all the intersection points already ordered with the right direction (from source to target vertex)\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i vect} The vector that will be filled with the intersection points of each new edge \par
{\i SRC} Source vertex of the current edge \par
{\i TGT} Target vertex of the current edge \par
{\i G} Graph \par
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid void \par
}}}
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v compare\:io_graph_imp.hpp}
{\xe \v io_graph_imp.hpp\:compare}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Graph , bool src_less_than_tgt> bool compare ({\comment (startParameterList)}
std::pair< point< 2 >, typename boost::graph_traits< Graph >::edge_descriptor > {\i pair1}, {\comment (startParameterList)}
  std::pair< point< 2 >, typename boost::graph_traits< Graph >::edge_descriptor > {\i pair2}){\f2  [inline]}{\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Helper function for check_for intersection. }{\comment endParagraph}
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given a couple of points, this function orders the intersection points according to the template parameter src_less_than_tgt. The ordering is needed in order to craete the new edges in the right way, preserving the direction of the fractures.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i pair1} It is the intersection point between the current edge and the edge described by the second component of the pair \par
{\i pair2} It is the intersection point between the current edge and the edge described by the second component of the pair \par
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid bool \par
}}}
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v refine_graph\:io_graph_imp.hpp}
{\xe \v io_graph_imp.hpp\:refine_graph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Graph > void refine_graph ({\comment (startParameterList)}
Graph & {\i G}, {\comment (startParameterList)}
  typename std::vector< std::pair< point< 2 >, typename boost::graph_traits< Graph >::edge_descriptor > > const & {\i vect}, {\comment (startParameterList)}
  int {\i frac_number}, {\comment (startParameterList)}
  typename boost::graph_traits< Graph >::vertex_descriptor {\i src}, {\comment (startParameterList)}
  typename boost::graph_traits< Graph >::vertex_descriptor {\i tgt}){\f2  [inline]}{\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Helper function for read_Formaggia_format. }{\comment endParagraph}
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function breaks old edges to create a refined graph according to the intersection points found while inserting the current edge. It preserves the fracture number of each old edge while creating the new ones.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i G} Graph \par
{\i vect} The vector of the intersection points \par
{\i frac_number} The fracture number of the current edge \par
{\i src} Vertex descriptor of the source of the current edge \par
{\i tgt} Vertex descriptor of the target of the current edge \par
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid void \par
}}}
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v vertex_insertion_or_identification\:io_graph_imp.hpp}
{\xe \v io_graph_imp.hpp\:vertex_insertion_or_identification}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Graph > boost::graph_traits<Graph>::vertex_descriptor vertex_insertion_or_identification ({\comment (startParameterList)}
Graph & {\i G}, {\comment (startParameterList)}
  point< 2 > const & {\i P}){\f2  [inline]}{\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Helper function for read_Formaggia_format. }{\comment endParagraph}
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The function checks if the vertex we are trying to insert is already present in the graph, (in this case it will be ignored) or if it isn't already present (in this case it will be inserted).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i G} Graph we are constructing \par
{\i P} Point we want to check if is present or not \par
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid vertex_descriptor \par
}}}
{\comment endFile}
{\comment end include io__graph__imp_8hpp.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include maximum__flow_8hpp.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
include/maximum_flow.hpp File Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v include/maximum_flow.hpp}
{\xe \v include/maximum_flow.hpp}
{\comment writeAnchor (maximum__flow_8hpp)}
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Header file for managing maximum_flow algorithm from BGL. }{\comment endParagraph}
}\par
{\comment startTextBlock}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <map>}{\comment (lineBreak)}
\par
{\f2 #include <tuple>}{\comment (lineBreak)}
\par
{\f2 #include <boost/graph/adjacency_list.hpp>}{\comment (lineBreak)}
\par
{\f2 #include <boost/graph/push_relabel_max_flow.hpp>}{\comment (lineBreak)}
\par
{\f2 #include <boost/property_map/property_map.hpp>}{\comment (lineBreak)}
\par
{\f2 #include <boost/graph/properties.hpp>}{\comment (lineBreak)}
\par
{\f2 #include "generic_point.hpp"}{\comment (lineBreak)}
\par
{\f2 #include "edge_property_max_flow.hpp"}{\comment (lineBreak)}
\par
{\f2 #include "maximum_flow_imp.hpp"}{\comment (lineBreak)}
\par
{\comment endTextBlock}
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Graph , typename Edge_Descriptor_g > double {\b maximum_flow} (Graph const &G, typename boost::graph_traits< Graph >::vertex_descriptor s, typename boost::graph_traits< Graph >::vertex_descriptor t, std::map< Edge_Descriptor_g, double > &out_residual_capacity){\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It runs push_relabel_max_flow algorithm on graph G. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Graph , typename Flow_Graph , typename Edge_fg > void {\b build_flow_graph} (Graph const &G, Flow_Graph &FG, std::map< Edge_fg, Edge_fg > &rev_map){\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Helper function for maximum_flow. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Graph , typename Flow_Graph , typename Edge_Descriptor_g > void {\b store_residual_capacity} (Graph const &G, Flow_Graph const &FG, std::map< Edge_Descriptor_g, double > &out_residual_capacity){\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Helper function that stores residual capacity on edges after computation of max flow. }{\comment (endMemberDescription)}
}}
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Header file for managing maximum_flow algorithm from BGL. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Ilaria Speranza & Mattia Tantardini \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Sep 14, 2016  \par
}}{\comment endTextBlock}
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation{\comment endGroupHeader}
\par
\pard\plain 
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v build_flow_graph\:maximum_flow.hpp}
{\xe \v maximum_flow.hpp\:build_flow_graph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Graph , typename Flow_Graph , typename Edge_fg > void build_flow_graph ({\comment (startParameterList)}
Graph const & {\i G}, {\comment (startParameterList)}
  Flow_Graph & {\i FG}, {\comment (startParameterList)}
  std::map< Edge_fg, Edge_fg > & {\i rev_map}){\f2  [inline]}{\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Helper function for maximum_flow. }{\comment endParagraph}
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function build the flow graph associated to the input graph. This is because we want not to modify the original Graph passed as input in maximum_flow, and because the push_relabelmax_flow algorithm requires such a Graph. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i G} Graph \par
{\i FG} Flow graph that will be built inside the function. We need to build a new graph with a special structure in order to accomplish the requirments of boost::push_relabel_max_flow \par
{\i rev_map} Map that stores the reverse edge for each edge in the graph. It is needed to build Flow Graph. \par
}
}}
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v maximum_flow\:maximum_flow.hpp}
{\xe \v maximum_flow.hpp\:maximum_flow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Graph , typename Edge_Descriptor_g > double maximum_flow ({\comment (startParameterList)}
Graph const & {\i G}, {\comment (startParameterList)}
  typename boost::graph_traits< Graph >::vertex_descriptor {\i s}, {\comment (startParameterList)}
  typename boost::graph_traits< Graph >::vertex_descriptor {\i t}, {\comment (startParameterList)}
  std::map< Edge_Descriptor_g, double > & {\i out_residual_capacity}){\f2  [inline]}{\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It runs push_relabel_max_flow algorithm on graph G. }{\comment endParagraph}
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function find the maximum flow that can flow from node s to node t.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i G} Graph \par
{\i s} Source vertex chosen for the maximum flow problem \par
{\i t} Target vertex chosen for the maximum flow problem \par
{\i out_residual_capacity} Map that stores the residual capacity left in each edge \par
}
}}
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v store_residual_capacity\:maximum_flow.hpp}
{\xe \v maximum_flow.hpp\:store_residual_capacity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Graph , typename Flow_Graph , typename Edge_Descriptor_g > void store_residual_capacity ({\comment (startParameterList)}
Graph const & {\i G}, {\comment (startParameterList)}
  Flow_Graph const & {\i FG}, {\comment (startParameterList)}
  std::map< Edge_Descriptor_g, double > & {\i out_residual_capacity}){\f2  [inline]}{\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Helper function that stores residual capacity on edges after computation of max flow. }{\comment endParagraph}
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
We use a vector. Next step: using a map<Edge_descriptor, residual_capacity_value> This function search in the flow graph which edges have the same sources and target as the edges in G, so that we can associate the right residual capacity to the right original edge of G. This is because FG is a utility in order to run the push_relabel algorithm and it is destroied after exiting this function.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i G} Graph \par
{\i FG} Flow Graph \par
{\i out_residual_capacity} Map that stores the residual capacity left in each edge \par
}
}}
{\comment endFile}
{\comment end include maximum__flow_8hpp.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include maximum__flow__imp_8hpp.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
include/maximum_flow_imp.hpp File Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v include/maximum_flow_imp.hpp}
{\xe \v include/maximum_flow_imp.hpp}
{\comment writeAnchor (maximum__flow__imp_8hpp)}
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implementations of the functions defined in {\b maximum_flow.hpp}. }{\comment endParagraph}
}\par
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Graph , typename Edge_Descriptor_g > double {\b maximum_flow} (Graph const &G, typename boost::graph_traits< Graph >::vertex_descriptor s, typename boost::graph_traits< Graph >::vertex_descriptor t, std::map< Edge_Descriptor_g, double > &out_residual_capacity){\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It runs push_relabel_max_flow algorithm on graph G. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Graph , typename Flow_Graph , typename Edge_fg > void {\b build_flow_graph} (Graph const &G, Flow_Graph &FG, std::map< Edge_fg, Edge_fg > &rev_map){\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Helper function for maximum_flow. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Graph , typename Flow_Graph , typename Edge_Descriptor_g > void {\b store_residual_capacity} (Graph const &G, Flow_Graph const &FG, std::map< Edge_Descriptor_g, double > &out_residual_capacity){\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Helper function that stores residual capacity on edges after computation of max flow. }{\comment (endMemberDescription)}
}}
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implementations of the functions defined in {\b maximum_flow.hpp}. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Ilaria Speranza & Mattia Tantardini \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Sep 14, 2016 \par
}}{\comment endTextBlock}
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation{\comment endGroupHeader}
\par
\pard\plain 
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v build_flow_graph\:maximum_flow_imp.hpp}
{\xe \v maximum_flow_imp.hpp\:build_flow_graph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Graph , typename Flow_Graph , typename Edge_fg > void build_flow_graph ({\comment (startParameterList)}
Graph const & {\i G}, {\comment (startParameterList)}
  Flow_Graph & {\i FG}, {\comment (startParameterList)}
  std::map< Edge_fg, Edge_fg > & {\i rev_map}){\f2  [inline]}{\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Helper function for maximum_flow. }{\comment endParagraph}
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function build the flow graph associated to the input graph. This is because we want not to modify the original Graph passed as input in maximum_flow, and because the push_relabelmax_flow algorithm requires such a Graph. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i G} Graph \par
{\i FG} Flow graph that will be built inside the function. We need to build a new graph with a special structure in order to accomplish the requirments of boost::push_relabel_max_flow \par
{\i rev_map} Map that stores the reverse edge for each edge in the graph. It is needed to build Flow Graph. \par
}
}}
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v maximum_flow\:maximum_flow_imp.hpp}
{\xe \v maximum_flow_imp.hpp\:maximum_flow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Graph , typename Edge_Descriptor_g > double maximum_flow ({\comment (startParameterList)}
Graph const & {\i G}, {\comment (startParameterList)}
  typename boost::graph_traits< Graph >::vertex_descriptor {\i s}, {\comment (startParameterList)}
  typename boost::graph_traits< Graph >::vertex_descriptor {\i t}, {\comment (startParameterList)}
  std::map< Edge_Descriptor_g, double > & {\i out_residual_capacity}){\f2  [inline]}{\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It runs push_relabel_max_flow algorithm on graph G. }{\comment endParagraph}
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function find the maximum flow that can flow from node s to node t.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i G} Graph \par
{\i s} Source vertex chosen for the maximum flow problem \par
{\i t} Target vertex chosen for the maximum flow problem \par
{\i out_residual_capacity} Map that stores the residual capacity left in each edge \par
}
}}
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v store_residual_capacity\:maximum_flow_imp.hpp}
{\xe \v maximum_flow_imp.hpp\:store_residual_capacity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Graph , typename Flow_Graph , typename Edge_Descriptor_g > void store_residual_capacity ({\comment (startParameterList)}
Graph const & {\i G}, {\comment (startParameterList)}
  Flow_Graph const & {\i FG}, {\comment (startParameterList)}
  std::map< Edge_Descriptor_g, double > & {\i out_residual_capacity}){\f2  [inline]}{\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Helper function that stores residual capacity on edges after computation of max flow. }{\comment endParagraph}
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
We use a vector. Next step: using a map<Edge_descriptor, residual_capacity_value> This function search in the flow graph which edges have the same sources and target as the edges in G, so that we can associate the right residual capacity to the right original edge of G. This is because FG is a utility in order to run the push_relabel algorithm and it is destroied after exiting this function.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i G} Graph \par
{\i FG} Flow Graph \par
{\i out_residual_capacity} Map that stores the residual capacity left in each edge \par
}
}}
{\comment endFile}
{\comment end include maximum__flow__imp_8hpp.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include new__reader__class_8hpp.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
include/new_reader_class.hpp File Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v include/new_reader_class.hpp}
{\xe \v include/new_reader_class.hpp}
{\comment writeAnchor (new__reader__class_8hpp)}
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Base abstract class to read input file. }{\comment endParagraph}
}\par
{\comment startTextBlock}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <string>}{\comment (lineBreak)}
\par
{\f2 #include <fstream>}{\comment (lineBreak)}
\par
{\f2 #include <sstream>}{\comment (lineBreak)}
\par
{\f2 #include <iostream>}{\comment (lineBreak)}
\par
{\f2 #include <cstdlib>}{\comment (lineBreak)}
\par
{\f2 #include <exception>}{\comment (lineBreak)}
\par
{\comment endTextBlock}
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b no_topological_data}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An empty struct to handle the case the user do not need to store topological data  Inside this the user may put data as vertex and edge descriptor for the connettivity of the graph. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b new_reader_class< Source_data_structure, Target_data_structure, Edge_data_structure, Topological_data_structure >}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Abstract class that implements the functionality to read a file and get data from it  The users has to specify, in the derived class, all variables he need in order to store information read from the input file. Then, through the definition of Edge_data_structure and Vertex_data_structure, he can get separately all the information to put on edges and vertices. }{\comment (endMemberDescription)}
}}
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Base abstract class to read input file. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Ilaria Speranza & Mattia Tantardini \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Sept, 2016  This abstract class provides the user some methods and functionality to read data form the input file and check errors. \par
}}{\comment endTextBlock}
}
{\comment endFile}
{\comment end include new__reader__class_8hpp.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include new__reader__Zunino_8hpp.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
include/new_reader_Zunino.hpp File Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v include/new_reader_Zunino.hpp}
{\xe \v include/new_reader_Zunino.hpp}
{\comment writeAnchor (new__reader__Zunino_8hpp)}
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class for reading from Zunino files. }{\comment endParagraph}
}\par
{\comment startTextBlock}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "new_reader_class.hpp"}{\comment (lineBreak)}
\par
{\f2 #include "generic_point.hpp"}{\comment (lineBreak)}
\par
{\comment endTextBlock}
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Zunino_source_data}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Zunino_target_data}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Zunino_edge_data}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Zunino_topological_data}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Zunino_reader< Zunino_source_data, Zunino_target_data, Zunino_edge_data, Zunino_topological_data >}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class for reading from Zunino files. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Ilaria Speranza & Mattia Tantardini \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Sept, 2016  In this header file the user has to implement: \par{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
A struct to handle data which will be put as edge_property \par\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
A struct to handle data which will be put as vertex_property \par\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
A reader class that inherits from {\b new_reader_class}, in which the user has to put all variables that will be read from input file and override all abstract methods \par}
}}{\comment endTextBlock}
}
{\comment endFile}
{\comment end include new__reader__Zunino_8hpp.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include our__disjoint__sets_8hpp.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
include/our_disjoint_sets.hpp File Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v include/our_disjoint_sets.hpp}
{\xe \v include/our_disjoint_sets.hpp}
{\comment writeAnchor (our__disjoint__sets_8hpp)}
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class to handle disjoint sets . }{\comment endParagraph}
}\par
{\comment startTextBlock}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <iostream>}{\comment (lineBreak)}
\par
{\f2 #include <map>}{\comment (lineBreak)}
\par
{\f2 #include <tuple>}{\comment (lineBreak)}
\par
{\f2 #include <list>}{\comment (lineBreak)}
\par
{\f2 #include <boost/graph/graph_traits.hpp>}{\comment (lineBreak)}
\par
{\comment endTextBlock}
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b our_disjoint_sets< Graph >}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Template class to handle disjoint sets  The template parameters are:\par Label_map_t: the type of a std::map which key is a vertex descriptor and the value is an unsigned int which has the meaning of the current label of the component to which that vertex belongs to.\par Components_map_t: the type of a std::map which key is an unsigned int used as label for the group and the value is a std::set containing all the vertex descriptor of the vertices that have that label, i.e that belong to the same component. }{\comment (endMemberDescription)}
}}
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class to handle disjoint sets . \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Ilaria Speranza & Mattia Tantardini \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Sep 2016. \par
}}{\comment endTextBlock}
}
{\comment endFile}
{\comment end include our__disjoint__sets_8hpp.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include reader__base__class_8hpp.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
include/reader_base_class.hpp File Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v include/reader_base_class.hpp}
{\xe \v include/reader_base_class.hpp}
{\comment writeAnchor (reader__base__class_8hpp)}
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Base abstract class to read input file and creating the graph. }{\comment endParagraph}
}\par
{\comment startTextBlock}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <iostream>}{\comment (lineBreak)}
\par
{\f2 #include <string>}{\comment (lineBreak)}
\par
{\f2 #include <fstream>}{\comment (lineBreak)}
\par
{\f2 #include <sstream>}{\comment (lineBreak)}
\par
{\f2 #include <boost/graph/graph_traits.hpp>}{\comment (lineBreak)}
\par
{\comment endTextBlock}
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b reader_base_class< Graph >}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Base abstract class to read input file and creating the graph. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Ilaria Speranza & Mattia Tantardini \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Sept, 2016  It contains all the variables needed to read an input file and to store a graph. It allows to specify how to read the imput file through the abrstract methods. \par
}}{\comment endTextBlock}
}
{\comment endFile}
{\comment end include reader__base__class_8hpp.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include reader__Formaggia__class_8hpp.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
include/reader_Formaggia_class.hpp File Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v include/reader_Formaggia_class.hpp}
{\xe \v include/reader_Formaggia_class.hpp}
{\comment writeAnchor (reader__Formaggia__class_8hpp)}
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implementation of the {\b reader_base_class} for the Formaggia file format. }{\comment endParagraph}
}\par
{\comment startTextBlock}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <algorithm>}{\comment (lineBreak)}
\par
{\f2 #include "reader_base_class.hpp"}{\comment (lineBreak)}
\par
{\f2 #include "intersector_base_class.hpp"}{\comment (lineBreak)}
\par
{\f2 #include "generic_point.hpp"}{\comment (lineBreak)}
\par
{\comment endTextBlock}
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b final< Graph >}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implementation of the {\b reader_base_class} for the Formaggia file format. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Ilaria Speranza & Mattia Tantardini \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Sept, 2016 \par
}}{\comment endTextBlock}
}
{\comment endFile}
{\comment end include reader__Formaggia__class_8hpp.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include reader__Zunino__class_8hpp.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
include/reader_Zunino_class.hpp File Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v include/reader_Zunino_class.hpp}
{\xe \v include/reader_Zunino_class.hpp}
{\comment writeAnchor (reader__Zunino__class_8hpp)}
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implementation of the reader for Zunino file format. }{\comment endParagraph}
}\par
{\comment startTextBlock}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <tuple>}{\comment (lineBreak)}
\par
{\f2 #include <iostream>}{\comment (lineBreak)}
\par
{\f2 #include "reader_base_class.hpp"}{\comment (lineBreak)}
\par
{\f2 #include "generic_point.hpp"}{\comment (lineBreak)}
\par
{\comment endTextBlock}
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b final< Graph >}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implementation of the reader for Zunino file format. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Ilaria Speranza & Mattia Tantardini \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Sept, 2016 \par
}}{\comment endTextBlock}
}
{\comment endFile}
{\comment end include reader__Zunino__class_8hpp.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include topological__distance_8hpp.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
include/topological_distance.hpp File Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v include/topological_distance.hpp}
{\xe \v include/topological_distance.hpp}
{\comment writeAnchor (topological__distance_8hpp)}
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes topological distance. . }{\comment endParagraph}
}\par
{\comment startTextBlock}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "topological_distance_imp.hpp"}{\comment (lineBreak)}
\par
{\comment endTextBlock}
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

template<typename Graph > void {\b dijkstra} (Graph const &G, typename boost::graph_traits< Graph >::vertex_descriptor s){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes topological distance. . \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Ilaria Speranza & Mattia Tantardini \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Sep 2016. \par
}}{\comment endTextBlock}
}
{\comment endFile}
{\comment end include topological__distance_8hpp.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include topological__distance__imp_8hpp.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
include/topological_distance_imp.hpp File Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v include/topological_distance_imp.hpp}
{\xe \v include/topological_distance_imp.hpp}
{\comment writeAnchor (topological__distance__imp_8hpp)}
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes topological distance. . }{\comment endParagraph}
}\par
{\comment startTextBlock}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <boost/graph/dijkstra_shortest_paths.hpp>}{\comment (lineBreak)}
\par
{\f2 #include <boost/graph/adjacency_list.hpp>}{\comment (lineBreak)}
\par
{\f2 #include <vector>}{\comment (lineBreak)}
\par
{\f2 #include "edge_property.hpp"}{\comment (lineBreak)}
\par
{\comment endTextBlock}
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

template<typename Graph > double {\b dijkstra} (Graph const &G, typename boost::graph_traits< Graph >::vertex_descriptor s, typename boost::graph_traits< Graph >::vertex_descriptor t, std::vector< typename boost::graph_traits< Graph >::vertex_descriptor > &v){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Computes topological distance. . \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Ilaria Speranza & Mattia Tantardini \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Sep 2016. \par
}}{\comment endTextBlock}
}
{\comment endFile}
{\comment end include topological__distance__imp_8hpp.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include Zunino__edge__property_8hpp.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
include/Zunino_edge_property.hpp File Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v include/Zunino_edge_property.hpp}
{\xe \v include/Zunino_edge_property.hpp}
{\comment writeAnchor (Zunino__edge__property_8hpp)}
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the struct for edge properties in Zunino's problem. }{\comment endParagraph}
}\par
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Zunino_edge_property_t}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the struct for edge properties in Zunino's problem. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Ilaria Speranza & Mattia Tantardini \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Sept, 2016 \par
}}{\comment endTextBlock}
}
{\comment endFile}
{\comment end include Zunino__edge__property_8hpp.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include main__Formaggia_8cpp.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/main_Formaggia.cpp File Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v src/main_Formaggia.cpp}
{\xe \v src/main_Formaggia.cpp}
{\comment writeAnchor (main__Formaggia_8cpp)}
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Source code for Formaggia's example . }{\comment endParagraph}
}\par
{\comment startTextBlock}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <iostream>}{\comment (lineBreak)}
\par
{\f2 #include <string>}{\comment (lineBreak)}
\par
{\f2 #include <boost/graph/adjacency_list.hpp>}{\comment (lineBreak)}
\par
{\f2 #include "Forma_vertex_property.hpp"}{\comment (lineBreak)}
\par
{\f2 #include "Forma_edge_property.hpp"}{\comment (lineBreak)}
\par
{\f2 #include "reader_Formaggia_class.hpp"}{\comment (lineBreak)}
\par
{\comment endTextBlock}
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

int {\b main} (){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Source code for Formaggia's example . \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Ilaria Speranza & Mattia Tantardini \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Sept, 2016 \par
}}{\comment endTextBlock}
}
{\comment endFile}
{\comment end include main__Formaggia_8cpp.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include main__Zunino_8cpp.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/main_Zunino.cpp File Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v src/main_Zunino.cpp}
{\xe \v src/main_Zunino.cpp}
{\comment writeAnchor (main__Zunino_8cpp)}
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Source code for Zunino example. . }{\comment endParagraph}
}\par
{\comment startTextBlock}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <iostream>}{\comment (lineBreak)}
\par
{\f2 #include <string>}{\comment (lineBreak)}
\par
{\f2 #include <vector>}{\comment (lineBreak)}
\par
{\f2 #include <tuple>}{\comment (lineBreak)}
\par
{\f2 #include <boost/graph/adjacency_list.hpp>}{\comment (lineBreak)}
\par
{\f2 #include "new_reader_Zunino.hpp"}{\comment (lineBreak)}
\par
{\f2 #include "graph_builder.hpp"}{\comment (lineBreak)}
\par
{\comment endTextBlock}
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

int {\b main} (){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Source code for Zunino example. . \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Ilaria Speranza & Mattia Tantardini \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Sept, 2016 \par
}}{\comment endTextBlock}
}
{\comment endFile}
{\comment end include main__Zunino_8cpp.rtf}

{\comment BeginRTFChapter}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
{\comment endFile}
}